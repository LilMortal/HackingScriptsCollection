#!/usr/bin/env python3
"""
SSL Certificate Validator Script

A comprehensive tool for validating SSL/TLS certificates from websites.
This script checks certificate expiration, chain validity, hostname matching,
and provides detailed certificate information.

Usage:
    python ssl_cert_validator.py example.com
    python ssl_cert_validator.py example.com --port 443 --timeout 10 --verbose
    python ssl_cert_validator.py --file domains.txt --output results.json

Author: Security Team
License: MIT
"""

import ssl
import socket
import argparse
import json
import sys
import datetime
import logging
from urllib.parse import urlparse
from typing import Dict, List, Optional, Tuple
import concurrent.futures
import threading

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class SSLCertificateValidator:
    """
    SSL Certificate validation class that provides comprehensive certificate checking.
    """
    
    def __init__(self, timeout: int = 10):
        """
        Initialize the SSL Certificate Validator.
        
        Args:
            timeout (int): Connection timeout in seconds
        """
        self.timeout = timeout
        self.results = []
        self.lock = threading.Lock()
    
    def validate_certificate(self, hostname: str, port: int = 443) -> Dict:
        """
        Validate SSL certificate for a given hostname and port.
        
        Args:
            hostname (str): The hostname to check
            port (int): The port to connect to (default: 443)
            
        Returns:
            Dict: Dictionary containing validation results
        """
        result = {
            'hostname': hostname,
            'port': port,
            'timestamp': datetime.datetime.now().isoformat(),
            'valid': False,
            'errors': [],
            'warnings': [],
            'certificate_info': {}
        }
        
        try:
            # Create SSL context with default settings
            context = ssl.create_default_context()
            
            # Connect to the server
            with socket.create_connection((hostname, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    # Get certificate information
                    cert = ssock.getpeercert()
                    cert_der = ssock.getpeercert(binary_form=True)
                    
                    # Parse certificate details
                    result['certificate_info'] = self._parse_certificate(cert, cert_der)
                    
                    # Perform validations
                    self._check_expiration(cert, result)
                    self._check_hostname(cert, hostname, result)
                    self._check_issuer(cert, result)
                    self._check_signature_algorithm(cert, result)
                    
                    # If no errors, certificate is valid
                    if not result['errors']:
                        result['valid'] = True
                        
        except ssl.SSLError as e:
            result['errors'].append(f"SSL Error: {str(e)}")
        except socket.timeout:
            result['errors'].append("Connection timeout")
        except socket.gaierror as e:
            result['errors'].append(f"DNS resolution failed: {str(e)}")
        except Exception as e:
            result['errors'].append(f"Unexpected error: {str(e)}")
        
        return result
    
    def _parse_certificate(self, cert: Dict, cert_der: bytes) -> Dict:
        """
        Parse certificate information into a structured format.
        
        Args:
            cert (Dict): Certificate information from getpeercert()
            cert_der (bytes): DER-encoded certificate
            
        Returns:
            Dict: Parsed certificate information
        """
        cert_info = {
            'subject': dict(x[0] for x in cert.get('subject', [])),
            'issuer': dict(x[0] for x in cert.get('issuer', [])),
            'version': cert.get('version'),
            'serial_number': cert.get('serialNumber'),
            'not_before': cert.get('notBefore'),
            'not_after': cert.get('notAfter'),
            'signature_algorithm': cert.get('signatureAlgorithm'),
            'public_key_info': self._get_public_key_info(cert),
            'extensions': self._parse_extensions(cert),
            'fingerprint_sha256': self._get_fingerprint(cert_der, 'sha256'),
            'fingerprint_sha1': self._get_fingerprint(cert_der, 'sha1')
        }
        
        return cert_info
    
    def _get_public_key_info(self, cert: Dict) -> Dict:
        """Extract public key information from certificate."""
        try:
            # This is a simplified version - in practice, you might want more detailed info
            return {
                'algorithm': cert.get('publicKey', {}).get('algorithm', 'Unknown'),
                'size': cert.get('publicKey', {}).get('size', 'Unknown')
            }
        except:
            return {'algorithm': 'Unknown', 'size': 'Unknown'}
    
    def _parse_extensions(self, cert: Dict) -> List[Dict]:
        """Parse certificate extensions."""
        extensions = []
        
        # Subject Alternative Names
        if 'subjectAltName' in cert:
            san_list = [f"{san[0]}:{san[1]}" for san in cert['subjectAltName']]
            extensions.append({
                'name': 'Subject Alternative Name',
                'value': ', '.join(san_list)
            })
        
        return extensions
    
    def _get_fingerprint(self, cert_der: bytes, algorithm: str) -> str:
        """Calculate certificate fingerprint."""
        import hashlib
        
        if algorithm.lower() == 'sha256':
            hash_obj = hashlib.sha256(cert_der)
        elif algorithm.lower() == 'sha1':
            hash_obj = hashlib.sha1(cert_der)
        else:
            return 'Unknown'
        
        return ':'.join([hash_obj.hexdigest()[i:i+2] for i in range(0, len(hash_obj.hexdigest()), 2)]).upper()
    
    def _check_expiration(self, cert: Dict, result: Dict):
        """Check certificate expiration."""
        try:
            not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
            not_before = datetime.datetime.strptime(cert['notBefore'], '%b %d %H:%M:%S %Y %Z')
            now = datetime.datetime.now()
            
            if now > not_after:
                result['errors'].append(f"Certificate expired on {cert['notAfter']}")
            elif now < not_before:
                result['errors'].append(f"Certificate not yet valid (valid from {cert['notBefore']})")
            else:
                days_until_expiry = (not_after - now).days
                if days_until_expiry <= 30:
                    result['warnings'].append(f"Certificate expires in {days_until_expiry} days")
                    
        except Exception as e:
            result['errors'].append(f"Could not parse certificate dates: {str(e)}")
    
    def _check_hostname(self, cert: Dict, hostname: str, result: Dict):
        """Check if certificate matches the hostname."""
        try:
            # Get subject common name
            subject_dict = dict(x[0] for x in cert.get('subject', []))
            common_name = subject_dict.get('commonName', '')
            
            # Get subject alternative names
            san_list = []
            if 'subjectAltName' in cert:
                san_list = [san[1] for san in cert['subjectAltName'] if san[0] == 'DNS']
            
            # Check if hostname matches
            hostname_matches = False
            
            # Check common name
            if self._hostname_matches(hostname, common_name):
                hostname_matches = True
            
            # Check SANs
            for san in san_list:
                if self._hostname_matches(hostname, san):
                    hostname_matches = True
                    break
            
            if not hostname_matches:
                result['errors'].append(f"Hostname '{hostname}' does not match certificate")
                
        except Exception as e:
            result['errors'].append(f"Could not verify hostname: {str(e)}")
    
    def _hostname_matches(self, hostname: str, cert_name: str) -> bool:
        """Check if hostname matches certificate name (supports wildcards)."""
        if cert_name.startswith('*.'):
            # Wildcard certificate
            cert_domain = cert_name[2:]
            if '.' in hostname:
                hostname_domain = '.'.join(hostname.split('.')[1:])
                return hostname_domain == cert_domain
        else:
            return hostname.lower() == cert_name.lower()
        
        return False
    
    def _check_issuer(self, cert: Dict, result: Dict):
        """Check certificate issuer information."""
        try:
            issuer_dict = dict(x[0] for x in cert.get('issuer', []))
            
            # Check for self-signed certificates
            subject_dict = dict(x[0] for x in cert.get('subject', []))
            
            if issuer_dict == subject_dict:
                result['warnings'].append("Certificate is self-signed")
                
        except Exception as e:
            result['warnings'].append(f"Could not analyze issuer: {str(e)}")
    
    def _check_signature_algorithm(self, cert: Dict, result: Dict):
        """Check certificate signature algorithm."""
        try:
            sig_alg = cert.get('signatureAlgorithm', '').lower()
            
            # Check for weak signature algorithms
            weak_algorithms = ['md5', 'sha1withrsaencryption']
            
            for weak_alg in weak_algorithms:
                if weak_alg in sig_alg:
                    result['warnings'].append(f"Weak signature algorithm: {cert.get('signatureAlgorithm')}")
                    break
                    
        except Exception as e:
            result['warnings'].append(f"Could not analyze signature algorithm: {str(e)}")
    
    def validate_multiple(self, hostnames: List[str], port: int = 443, max_workers: int = 10) -> List[Dict]:
        """
        Validate multiple hostnames concurrently.
        
        Args:
            hostnames (List[str]): List of hostnames to validate
            port (int): Port to connect to
            max_workers (int): Maximum number of concurrent workers
            
        Returns:
            List[Dict]: List of validation results
        """
        results = []
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_hostname = {
                executor.submit(self.validate_certificate, hostname, port): hostname 
                for hostname in hostnames
            }
            
            for future in concurrent.futures.as_completed(future_to_hostname):
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    hostname = future_to_hostname[future]
                    logger.error(f"Error validating {hostname}: {str(e)}")
        
        return results


def load_hostnames_from_file(filename: str) -> List[str]:
    """
    Load hostnames from a text file (one per line).
    
    Args:
        filename (str): Path to the file containing hostnames
        
    Returns:
        List[str]: List of hostnames
    """
    try:
        with open(filename, 'r') as f:
            hostnames = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        return hostnames
    except FileNotFoundError:
        logger.error(f"File not found: {filename}")
        return []
    except Exception as e:
        logger.error(f"Error reading file {filename}: {str(e)}")
        return []


def save_results_to_file(results: List[Dict], filename: str, format_type: str = 'json'):
    """
    Save validation results to a file.
    
    Args:
        results (List[Dict]): Validation results
        filename (str): Output filename
        format_type (str): Output format ('json' or 'csv')
    """
    try:
        if format_type.lower() == 'json':
            with open(filename, 'w') as f:
                json.dump(results, f, indent=2, default=str)
        elif format_type.lower() == 'csv':
            import csv
            with open(filename, 'w', newline='') as f:
                if results:
                    fieldnames = ['hostname', 'port', 'valid', 'errors', 'warnings', 'expires']
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    
                    for result in results:
                        row = {
                            'hostname': result['hostname'],
                            'port': result['port'],
                            'valid': result['valid'],
                            'errors': '; '.join(result['errors']),
                            'warnings': '; '.join(result['warnings']),
                            'expires': result['certificate_info'].get('not_after', 'Unknown')
                        }
                        writer.writerow(row)
        
        logger.info(f"Results saved to {filename}")
        
    except Exception as e:
        logger.error(f"Error saving results to {filename}: {str(e)}")


def print_result(result: Dict, verbose: bool = False):
    """
    Print validation result in a formatted way.
    
    Args:
        result (Dict): Validation result
        verbose (bool): Whether to print detailed information
    """
    status = "✓ VALID" if result['valid'] else "✗ INVALID"
    print(f"\n{result['hostname']}:{result['port']} - {status}")
    
    if result['errors']:
        print("  Errors:")
        for error in result['errors']:
            print(f"    • {error}")
    
    if result['warnings']:
        print("  Warnings:")
        for warning in result['warnings']:
            print(f"    • {warning}")
    
    if verbose and result['certificate_info']:
        cert_info = result['certificate_info']
        print("  Certificate Details:")
        print(f"    Subject: {cert_info.get('subject', {}).get('commonName', 'Unknown')}")
        print(f"    Issuer: {cert_info.get('issuer', {}).get('organizationName', 'Unknown')}")
        print(f"    Valid From: {cert_info.get('not_before', 'Unknown')}")
        print(f"    Valid Until: {cert_info.get('not_after', 'Unknown')}")
        print(f"    Serial Number: {cert_info.get('serial_number', 'Unknown')}")
        print(f"    Signature Algorithm: {cert_info.get('signature_algorithm', 'Unknown')}")
        print(f"    SHA256 Fingerprint: {cert_info.get('fingerprint_sha256', 'Unknown')}")


def main():
    """Main function to handle command line arguments and execute validation."""
    parser = argparse.ArgumentParser(
        description='SSL Certificate Validator - Validate SSL/TLS certificates',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s example.com
  %(prog)s example.com --port 8443 --timeout 15
  %(prog)s --file domains.txt --output results.json
  %(prog)s example.com --verbose
        """
    )
    
    # Hostname argument
    parser.add_argument(
        'hostname',
        nargs='?',
        help='Hostname to validate (required if --file is not used)'
    )
    
    # Optional arguments
    parser.add_argument(
        '--port', '-p',
        type=int,
        default=443,
        help='Port to connect to (default: 443)'
    )
    
    parser.add_argument(
        '--timeout', '-t',
        type=int,
        default=10,
        help='Connection timeout in seconds (default: 10)'
    )
    
    parser.add_argument(
        '--file', '-f',
        help='File containing hostnames to validate (one per line)'
    )
    
    parser.add_argument(
        '--output', '-o',
        help='Output file for results (JSON format)'
    )
    
    parser.add_argument(
        '--format',
        choices=['json', 'csv'],
        default='json',
        help='Output format (default: json)'
    )
    
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Show detailed certificate information'
    )
    
    parser.add_argument(
        '--workers',
        type=int,
        default=10,
        help='Maximum number of concurrent workers (default: 10)'
    )
    
    args = parser.parse_args()
    
    # Validate arguments
    if not args.hostname and not args.file:
        parser.error('Either hostname or --file must be specified')
    
    # Initialize validator
    validator = SSLCertificateValidator(timeout=args.timeout)
    
    # Determine hostnames to validate
    if args.file:
        hostnames = load_hostnames_from_file(args.file)
        if not hostnames:
            sys.exit(1)
        results = validator.validate_multiple(hostnames, args.port, args.workers)
    else:
        results = [validator.validate_certificate(args.hostname, args.port)]
    
    # Print results
    for result in results:
        print_result(result, args.verbose)
    
    # Save results if output file specified
    if args.output:
        save_results_to_file(results, args.output, args.format)
    
    # Print summary
    valid_count = sum(1 for r in results if r['valid'])
    total_count = len(results)
    print(f"\nSummary: {valid_count}/{total_count} certificates are valid")
    
    # Exit with appropriate code
    sys.exit(0 if valid_count == total_count else 1)


if __name__ == '__main__':
    main()
