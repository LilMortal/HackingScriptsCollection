#!/usr/bin/env python3
"""
Penetration Testing Documentation Script

A comprehensive tool for documenting authorized penetration testing activities.
This script helps security professionals maintain structured records of their
testing procedures, findings, and recommendations.

Usage:
    python pentest_doc.py --action create_project --name "MyPentest" --client "ClientName"
    python pentest_doc.py --action add_finding --project "MyPentest" --severity high
    python pentest_doc.py --action generate_report --project "MyPentest" --format pdf

Author: Security Team
License: MIT
"""

import argparse
import json
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
import logging
import hashlib


class PentestDocumentationError(Exception):
    """Custom exception for penetration testing documentation errors."""
    pass


class PentestProject:
    """
    Represents a penetration testing project with all associated documentation.
    """
    
    def __init__(self, name: str, client: str, tester: str = ""):
        """
        Initialize a new penetration testing project.
        
        Args:
            name: Project name/identifier
            client: Client organization name
            tester: Name of the penetration tester
        """
        self.name = name
        self.client = client
        self.tester = tester
        self.created_date = datetime.now().isoformat()
        self.findings = []
        self.scope = []
        self.methodology = []
        self.executive_summary = ""
        self.recommendations = []
        
    def to_dict(self) -> Dict:
        """Convert project to dictionary for JSON serialization."""
        return {
            'name': self.name,
            'client': self.client,
            'tester': self.tester,
            'created_date': self.created_date,
            'findings': self.findings,
            'scope': self.scope,
            'methodology': self.methodology,
            'executive_summary': self.executive_summary,
            'recommendations': self.recommendations
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'PentestProject':
        """Create project instance from dictionary."""
        project = cls(data['name'], data['client'], data.get('tester', ''))
        project.created_date = data.get('created_date', datetime.now().isoformat())
        project.findings = data.get('findings', [])
        project.scope = data.get('scope', [])
        project.methodology = data.get('methodology', [])
        project.executive_summary = data.get('executive_summary', '')
        project.recommendations = data.get('recommendations', [])
        return project


class PentestDocumentation:
    """
    Main class for managing penetration testing documentation.
    """
    
    SEVERITY_LEVELS = ['critical', 'high', 'medium', 'low', 'info']
    REPORT_FORMATS = ['json', 'html', 'markdown']
    
    def __init__(self, workspace_dir: str = "./pentest_workspace"):
        """
        Initialize the documentation manager.
        
        Args:
            workspace_dir: Directory to store project files
        """
        self.workspace_dir = Path(workspace_dir)
        self.workspace_dir.mkdir(exist_ok=True)
        
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(self.workspace_dir / 'pentest_doc.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
        
    def create_project(self, name: str, client: str, tester: str = "") -> None:
        """
        Create a new penetration testing project.
        
        Args:
            name: Project name
            client: Client organization
            tester: Penetration tester name
            
        Raises:
            PentestDocumentationError: If project already exists
        """
        project_file = self.workspace_dir / f"{name}.json"
        
        if project_file.exists():
            raise PentestDocumentationError(f"Project '{name}' already exists")
        
        project = PentestProject(name, client, tester)
        self._save_project(project)
        
        self.logger.info(f"Created new project: {name} for client: {client}")
        print(f"✓ Created project '{name}' for client '{client}'")
        
    def load_project(self, name: str) -> PentestProject:
        """
        Load an existing project.
        
        Args:
            name: Project name
            
        Returns:
            PentestProject instance
            
        Raises:
            PentestDocumentationError: If project doesn't exist
        """
        project_file = self.workspace_dir / f"{name}.json"
        
        if not project_file.exists():
            raise PentestDocumentationError(f"Project '{name}' not found")
        
        try:
            with open(project_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            return PentestProject.from_dict(data)
        except (json.JSONDecodeError, KeyError) as e:
            raise PentestDocumentationError(f"Error loading project: {e}")
    
    def _save_project(self, project: PentestProject) -> None:
        """Save project to disk."""
        project_file = self.workspace_dir / f"{project.name}.json"
        
        try:
            with open(project_file, 'w', encoding='utf-8') as f:
                json.dump(project.to_dict(), f, indent=2, ensure_ascii=False)
        except IOError as e:
            raise PentestDocumentationError(f"Error saving project: {e}")
    
    def add_finding(self, project_name: str, title: str, severity: str,
                   description: str = "", impact: str = "", 
                   recommendation: str = "", cvss_score: float = 0.0) -> None:
        """
        Add a security finding to the project.
        
        Args:
            project_name: Name of the project
            title: Finding title
            severity: Severity level (critical, high, medium, low, info)
            description: Detailed description
            impact: Business impact
            recommendation: Remediation recommendation
            cvss_score: CVSS score (0.0-10.0)
        """
        if severity.lower() not in self.SEVERITY_LEVELS:
            raise PentestDocumentationError(f"Invalid severity. Must be one of: {self.SEVERITY_LEVELS}")
        
        if not (0.0 <= cvss_score <= 10.0):
            raise PentestDocumentationError("CVSS score must be between 0.0 and 10.0")
        
        project = self.load_project(project_name)
        
        finding = {
            'id': self._generate_finding_id(title),
            'title': title,
            'severity': severity.lower(),
            'description': description,
            'impact': impact,
            'recommendation': recommendation,
            'cvss_score': cvss_score,
            'date_found': datetime.now().isoformat(),
            'status': 'open'
        }
        
        project.findings.append(finding)
        self._save_project(project)
        
        self.logger.info(f"Added {severity} finding to project {project_name}: {title}")
        print(f"✓ Added {severity} severity finding: {title}")
    
    def _generate_finding_id(self, title: str) -> str:
        """Generate a unique ID for a finding."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        title_hash = hashlib.md5(title.encode()).hexdigest()[:8]
        return f"FIND_{timestamp}_{title_hash}"
    
    def add_scope_item(self, project_name: str, target: str, 
                      target_type: str = "network") -> None:
        """
        Add an item to the testing scope.
        
        Args:
            project_name: Name of the project
            target: Target specification (IP, domain, etc.)
            target_type: Type of target (network, web, mobile, etc.)
        """
        project = self.load_project(project_name)
        
        scope_item = {
            'target': target,
            'type': target_type,
            'added_date': datetime.now().isoformat()
        }
        
        project.scope.append(scope_item)
        self._save_project(project)
        
        self.logger.info(f"Added scope item to project {project_name}: {target}")
        print(f"✓ Added scope item: {target} ({target_type})")
    
    def list_projects(self) -> List[str]:
        """List all available projects."""
        projects = []
        for file_path in self.workspace_dir.glob("*.json"):
            if file_path.stem != 'pentest_doc':  # Exclude log files
                projects.append(file_path.stem)
        return sorted(projects)
    
    def generate_report(self, project_name: str, format_type: str = "markdown",
                       output_file: Optional[str] = None) -> str:
        """
        Generate a penetration testing report.
        
        Args:
            project_name: Name of the project
            format_type: Output format (json, html, markdown)
            output_file: Optional output file path
            
        Returns:
            Generated report content or file path
        """
        if format_type not in self.REPORT_FORMATS:
            raise PentestDocumentationError(f"Invalid format. Must be one of: {self.REPORT_FORMATS}")
        
        project = self.load_project(project_name)
        
        if format_type == "json":
            report_content = json.dumps(project.to_dict(), indent=2)
        elif format_type == "markdown":
            report_content = self._generate_markdown_report(project)
        elif format_type == "html":
            report_content = self._generate_html_report(project)
        
        if output_file:
            output_path = Path(output_file)
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(report_content)
            
            self.logger.info(f"Generated {format_type} report for project {project_name}: {output_path}")
            print(f"✓ Report generated: {output_path}")
            return str(output_path)
        
        return report_content
    
    def _generate_markdown_report(self, project: PentestProject) -> str:
        """Generate a markdown format report."""
        report = f"""# Penetration Testing Report

## Project Information
- **Project Name:** {project.name}
- **Client:** {project.client}
- **Tester:** {project.tester}
- **Date Created:** {project.created_date}
- **Total Findings:** {len(project.findings)}

## Executive Summary
{project.executive_summary or "No executive summary provided."}

## Scope
"""
        
        if project.scope:
            for item in project.scope:
                report += f"- {item['target']} ({item['type']})\n"
        else:
            report += "No scope items defined.\n"
        
        report += "\n## Findings\n"
        
        # Group findings by severity
        severity_groups = {}
        for finding in project.findings:
            severity = finding['severity']
            if severity not in severity_groups:
                severity_groups[severity] = []
            severity_groups[severity].append(finding)
        
        for severity in self.SEVERITY_LEVELS:
            if severity in severity_groups:
                report += f"\n### {severity.title()} Severity Findings\n"
                for finding in severity_groups[severity]:
                    report += f"\n#### {finding['title']}\n"
                    report += f"- **ID:** {finding['id']}\n"
                    report += f"- **CVSS Score:** {finding['cvss_score']}\n"
                    report += f"- **Status:** {finding['status']}\n"
                    if finding['description']:
                        report += f"- **Description:** {finding['description']}\n"
                    if finding['impact']:
                        report += f"- **Impact:** {finding['impact']}\n"
                    if finding['recommendation']:
                        report += f"- **Recommendation:** {finding['recommendation']}\n"
        
        if project.recommendations:
            report += "\n## General Recommendations\n"
            for i, rec in enumerate(project.recommendations, 1):
                report += f"{i}. {rec}\n"
        
        return report
    
    def _generate_html_report(self, project: PentestProject) -> str:
        """Generate an HTML format report."""
        html = f"""<!DOCTYPE html>
<html>
<head>
    <title>Penetration Testing Report - {project.name}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        .header {{ background-color: #f0f0f0; padding: 20px; border-radius: 5px; }}
        .finding {{ margin: 20px 0; padding: 15px; border-left: 4px solid #ccc; }}
        .critical {{ border-left-color: #d32f2f; }}
        .high {{ border-left-color: #f57c00; }}
        .medium {{ border-left-color: #fbc02d; }}
        .low {{ border-left-color: #388e3c; }}
        .info {{ border-left-color: #1976d2; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Penetration Testing Report</h1>
        <p><strong>Project:</strong> {project.name}</p>
        <p><strong>Client:</strong> {project.client}</p>
        <p><strong>Tester:</strong> {project.tester}</p>
        <p><strong>Date:</strong> {project.created_date}</p>
    </div>
    
    <h2>Executive Summary</h2>
    <p>{project.executive_summary or "No executive summary provided."}</p>
    
    <h2>Findings Summary</h2>
    <p>Total findings: {len(project.findings)}</p>
    
    <h2>Detailed Findings</h2>
"""
        
        for finding in project.findings:
            html += f"""
    <div class="finding {finding['severity']}">
        <h3>{finding['title']}</h3>
        <p><strong>Severity:</strong> {finding['severity'].title()}</p>
        <p><strong>CVSS Score:</strong> {finding['cvss_score']}</p>
        <p><strong>Description:</strong> {finding['description']}</p>
        <p><strong>Impact:</strong> {finding['impact']}</p>
        <p><strong>Recommendation:</strong> {finding['recommendation']}</p>
    </div>
"""
        
        html += """
</body>
</html>
"""
        return html


def main():
    """Main function to handle command-line interface."""
    parser = argparse.ArgumentParser(
        description="Penetration Testing Documentation Tool",
        epilog="""
Examples:
  %(prog)s --action create_project --name "WebApp2024" --client "ACME Corp" --tester "John Doe"
  %(prog)s --action add_finding --project "WebApp2024" --title "SQL Injection" --severity high
  %(prog)s --action add_scope --project "WebApp2024" --target "192.168.1.0/24" --type network
  %(prog)s --action generate_report --project "WebApp2024" --format markdown --output report.md
  %(prog)s --action list_projects
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('--action', required=True,
                       choices=['create_project', 'add_finding', 'add_scope', 
                               'generate_report', 'list_projects'],
                       help='Action to perform')
    
    parser.add_argument('--workspace', default='./pentest_workspace',
                       help='Workspace directory (default: ./pentest_workspace)')
    
    # Project-related arguments
    parser.add_argument('--name', help='Project name')
    parser.add_argument('--project', help='Existing project name')
    parser.add_argument('--client', help='Client organization name')
    parser.add_argument('--tester', help='Penetration tester name')
    
    # Finding-related arguments
    parser.add_argument('--title', help='Finding title')
    parser.add_argument('--severity', choices=['critical', 'high', 'medium', 'low', 'info'],
                       help='Finding severity level')
    parser.add_argument('--description', help='Finding description')
    parser.add_argument('--impact', help='Business impact')
    parser.add_argument('--recommendation', help='Remediation recommendation')
    parser.add_argument('--cvss', type=float, default=0.0, help='CVSS score (0.0-10.0)')
    
    # Scope-related arguments
    parser.add_argument('--target', help='Target specification')
    parser.add_argument('--type', default='network', help='Target type')
    
    # Report-related arguments
    parser.add_argument('--format', default='markdown',
                       choices=['json', 'html', 'markdown'],
                       help='Report format')
    parser.add_argument('--output', help='Output file path')
    
    args = parser.parse_args()
    
    try:
        doc_manager = PentestDocumentation(args.workspace)
        
        if args.action == 'create_project':
            if not args.name or not args.client:
                parser.error("--name and --client are required for create_project")
            doc_manager.create_project(args.name, args.client, args.tester or "")
            
        elif args.action == 'add_finding':
            if not args.project or not args.title or not args.severity:
                parser.error("--project, --title, and --severity are required for add_finding")
            doc_manager.add_finding(
                args.project, args.title, args.severity,
                args.description or "", args.impact or "",
                args.recommendation or "", args.cvss
            )
            
        elif args.action == 'add_scope':
            if not args.project or not args.target:
                parser.error("--project and --target are required for add_scope")
            doc_manager.add_scope_item(args.project, args.target, args.type)
            
        elif args.action == 'generate_report':
            if not args.project:
                parser.error("--project is required for generate_report")
            report = doc_manager.generate_report(args.project, args.format, args.output)
            if not args.output:
                print(report)
                
        elif args.action == 'list_projects':
            projects = doc_manager.list_projects()
            if projects:
                print("Available projects:")
                for project in projects:
                    print(f"  - {project}")
            else:
                print("No projects found.")
    
    except PentestDocumentationError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
