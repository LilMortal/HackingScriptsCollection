#!/usr/bin/env python3
"""
Network Scanner GUI - A legitimate network discovery tool for administrators

This script provides a graphical interface for scanning networks to discover
active hosts and open ports. It's designed for network administrators to 
audit their own networks for security purposes.

Usage:
    python network_scanner_gui.py
    python network_scanner_gui.py --target 192.168.1.0/24
    python network_scanner_gui.py --target 192.168.1.1 --ports 22,80,443

Requirements:
    - tkinter (standard library)
    - socket (standard library)
    - threading (standard library)
    - ipaddress (standard library)
    - argparse (standard library)

Author: Network Security Tool
License: MIT
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import socket
import threading
import ipaddress
import argparse
import sys
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
import json
from datetime import datetime


class NetworkScanner:
    """Core network scanning functionality"""
    
    def __init__(self):
        self.results = []
        self.scan_active = False
        
    def ping_host(self, ip_address, timeout=1):
        """
        Check if a host is reachable using socket connection
        
        Args:
            ip_address (str): IP address to check
            timeout (int): Connection timeout in seconds
            
        Returns:
            bool: True if host is reachable, False otherwise
        """
        try:
            # Try to connect to a common port to check if host is alive
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((str(ip_address), 80))
            sock.close()
            
            if result == 0:
                return True
            else:
                # Try another common port
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                result = sock.connect_ex((str(ip_address), 22))
                sock.close()
                return result == 0
        except Exception:
            return False
    
    def scan_port(self, ip_address, port, timeout=1):
        """
        Scan a specific port on a host
        
        Args:
            ip_address (str): IP address to scan
            port (int): Port number to scan
            timeout (int): Connection timeout in seconds
            
        Returns:
            bool: True if port is open, False otherwise
        """
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((str(ip_address), port))
            sock.close()
            return result == 0
        except Exception:
            return False
    
    def get_hostname(self, ip_address):
        """
        Get hostname for an IP address
        
        Args:
            ip_address (str): IP address
            
        Returns:
            str: Hostname or 'Unknown' if not found
        """
        try:
            hostname = socket.gethostbyaddr(str(ip_address))[0]
            return hostname
        except Exception:
            return "Unknown"
    
    def scan_network(self, network_range, ports=None, callback=None):
        """
        Scan a network range for active hosts and open ports
        
        Args:
            network_range (str): Network range in CIDR notation
            ports (list): List of ports to scan
            callback (function): Callback function for progress updates
        """
        if ports is None:
            ports = [22, 23, 53, 80, 110, 443, 993, 995]
        
        self.results = []
        self.scan_active = True
        
        try:
            network = ipaddress.ip_network(network_range, strict=False)
            total_hosts = network.num_addresses
            
            if total_hosts > 1000:
                if callback:
                    callback("Warning: Large network range detected. This may take a while.")
            
            # Use ThreadPoolExecutor for concurrent scanning
            with ThreadPoolExecutor(max_workers=50) as executor:
                futures = []
                
                for ip in network.hosts():
                    if not self.scan_active:
                        break
                    future = executor.submit(self._scan_host, str(ip), ports)
                    futures.append(future)
                
                completed = 0
                for future in as_completed(futures):
                    if not self.scan_active:
                        break
                    
                    result = future.result()
                    if result:
                        self.results.append(result)
                        if callback:
                            callback(f"Found active host: {result['ip']}")
                    
                    completed += 1
                    if callback and completed % 10 == 0:
                        progress = (completed / len(futures)) * 100
                        callback(f"Progress: {progress:.1f}% ({completed}/{len(futures)})")
                        
        except ValueError as e:
            if callback:
                callback(f"Error: Invalid network range - {e}")
        except Exception as e:
            if callback:
                callback(f"Error during scan: {e}")
        finally:
            self.scan_active = False
    
    def _scan_host(self, ip_address, ports):
        """
        Scan a single host for open ports
        
        Args:
            ip_address (str): IP address to scan
            ports (list): List of ports to scan
            
        Returns:
            dict: Host information if active, None otherwise
        """
        # First check if host is alive
        if not self.ping_host(ip_address):
            return None
        
        hostname = self.get_hostname(ip_address)
        open_ports = []
        
        # Scan specified ports
        for port in ports:
            if not self.scan_active:
                break
            if self.scan_port(ip_address, port):
                open_ports.append(port)
        
        return {
            'ip': ip_address,
            'hostname': hostname,
            'ports': open_ports,
            'timestamp': datetime.now().isoformat()
        }
    
    def stop_scan(self):
        """Stop the current scan"""
        self.scan_active = False


class NetworkScannerGUI:
    """GUI application for network scanning"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("Network Scanner - Security Audit Tool")
        self.root.geometry("800x600")
        
        self.scanner = NetworkScanner()
        self.scan_thread = None
        
        self.setup_gui()
        self.add_disclaimer()
        
    def setup_gui(self):
        """Initialize the GUI components"""
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(5, weight=1)
        
        # Target input
        ttk.Label(main_frame, text="Target Network:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.target_var = tk.StringVar(value="192.168.1.0/24")
        self.target_entry = ttk.Entry(main_frame, textvariable=self.target_var, width=30)
        self.target_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=5)
        
        # Ports input
        ttk.Label(main_frame, text="Ports (comma-separated):").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.ports_var = tk.StringVar(value="22,23,53,80,110,443,993,995")
        self.ports_entry = ttk.Entry(main_frame, textvariable=self.ports_var, width=30)
        self.ports_entry.grid(row=1, column=1, sticky=(tk.W, tk.E), pady=5)
        
        # Buttons frame
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.grid(row=2, column=0, columnspan=2, pady=10)
        
        self.scan_button = ttk.Button(buttons_frame, text="Start Scan", command=self.start_scan)
        self.scan_button.pack(side=tk.LEFT, padx=5)
        
        self.stop_button = ttk.Button(buttons_frame, text="Stop Scan", command=self.stop_scan, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=5)
        
        self.clear_button = ttk.Button(buttons_frame, text="Clear Results", command=self.clear_results)
        self.clear_button.pack(side=tk.LEFT, padx=5)
        
        self.export_button = ttk.Button(buttons_frame, text="Export Results", command=self.export_results)
        self.export_button.pack(side=tk.LEFT, padx=5)
        
        # Progress bar
        self.progress_var = tk.StringVar(value="Ready to scan")
        ttk.Label(main_frame, text="Status:").grid(row=3, column=0, sticky=tk.W, pady=5)
        self.status_label = ttk.Label(main_frame, textvariable=self.progress_var)
        self.status_label.grid(row=3, column=1, sticky=tk.W, pady=5)
        
        # Progress bar
        self.progress_bar = ttk.Progressbar(main_frame, mode='indeterminate')
        self.progress_bar.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        # Results display
        ttk.Label(main_frame, text="Scan Results:").grid(row=5, column=0, sticky=(tk.W, tk.N), pady=(10, 5))
        
        # Results text widget with scrollbar
        self.results_text = scrolledtext.ScrolledText(main_frame, height=20, width=80)
        self.results_text.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
    def add_disclaimer(self):
        """Add ethical use disclaimer"""
        disclaimer_text = """
ETHICAL USE DISCLAIMER:
This tool is intended for legitimate network administration and security auditing purposes only.
Only scan networks that you own or have explicit permission to test.
Unauthorized network scanning may violate local laws and regulations.
Use responsibly and ethically.
        """
        self.results_text.insert(tk.END, disclaimer_text)
        self.results_text.insert(tk.END, "\n" + "="*80 + "\n\n")
    
    def validate_inputs(self):
        """Validate user inputs"""
        target = self.target_var.get().strip()
        ports_str = self.ports_var.get().strip()
        
        if not target:
            messagebox.showerror("Error", "Please enter a target network")
            return None, None
        
        # Validate network range
        try:
            ipaddress.ip_network(target, strict=False)
        except ValueError:
            messagebox.showerror("Error", "Invalid network range format")
            return None, None
        
        # Validate ports
        try:
            if ports_str:
                ports = [int(p.strip()) for p in ports_str.split(',')]
                for port in ports:
                    if not (1 <= port <= 65535):
                        raise ValueError(f"Invalid port number: {port}")
            else:
                ports = None
        except ValueError as e:
            messagebox.showerror("Error", f"Invalid ports format: {e}")
            return None, None
        
        return target, ports
    
    def start_scan(self):
        """Start the network scan"""
        target, ports = self.validate_inputs()
        if target is None:
            return
        
        self.scan_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        self.progress_bar.start()
        
        self.results_text.insert(tk.END, f"Starting scan of {target}\n")
        self.results_text.insert(tk.END, f"Scanning ports: {ports if ports else 'default'}\n")
        self.results_text.insert(tk.END, f"Scan started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        self.results_text.see(tk.END)
        
        # Start scan in separate thread
        self.scan_thread = threading.Thread(
            target=self._run_scan,
            args=(target, ports),
            daemon=True
        )
        self.scan_thread.start()
    
    def _run_scan(self, target, ports):
        """Run the scan in a separate thread"""
        def update_callback(message):
            self.root.after(0, self._update_progress, message)
        
        self.scanner.scan_network(target, ports, update_callback)
        
        # Update GUI when scan completes
        self.root.after(0, self._scan_complete)
    
    def _update_progress(self, message):
        """Update progress in GUI thread"""
        self.progress_var.set(message)
        self.results_text.insert(tk.END, f"{message}\n")
        self.results_text.see(tk.END)
    
    def _scan_complete(self):
        """Handle scan completion"""
        self.progress_bar.stop()
        self.scan_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)
        
        if self.scanner.results:
            self.results_text.insert(tk.END, f"\nScan completed! Found {len(self.scanner.results)} active hosts:\n")
            self.results_text.insert(tk.END, "="*80 + "\n")
            
            for result in self.scanner.results:
                self.results_text.insert(tk.END, f"Host: {result['ip']}\n")
                self.results_text.insert(tk.END, f"Hostname: {result['hostname']}\n")
                if result['ports']:
                    self.results_text.insert(tk.END, f"Open Ports: {', '.join(map(str, result['ports']))}\n")
                else:
                    self.results_text.insert(tk.END, "Open Ports: None detected\n")
                self.results_text.insert(tk.END, "-" * 40 + "\n")
        else:
            self.results_text.insert(tk.END, "\nScan completed. No active hosts found.\n")
        
        self.progress_var.set("Scan completed")
        self.results_text.see(tk.END)
    
    def stop_scan(self):
        """Stop the current scan"""
        self.scanner.stop_scan()
        self.progress_var.set("Stopping scan...")
        self.stop_button.config(state=tk.DISABLED)
    
    def clear_results(self):
        """Clear the results display"""
        self.results_text.delete(1.0, tk.END)
        self.add_disclaimer()
        self.progress_var.set("Ready to scan")
    
    def export_results(self):
        """Export scan results to JSON file"""
        if not self.scanner.results:
            messagebox.showinfo("Info", "No results to export")
            return
        
        try:
            filename = f"network_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            with open(filename, 'w') as f:
                json.dump(self.scanner.results, f, indent=2)
            messagebox.showinfo("Success", f"Results exported to {filename}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export results: {e}")


def main():
    """Main function to run the application"""
    parser = argparse.ArgumentParser(
        description="Network Scanner GUI - A legitimate network discovery tool for administrators"
    )
    parser.add_argument(
        '--target',
        help='Target network range (e.g., 192.168.1.0/24)',
        default='192.168.1.0/24'
    )
    parser.add_argument(
        '--ports',
        help='Comma-separated list of ports to scan (e.g., 22,80,443)',
        default='22,23,53,80,110,443,993,995'
    )
    parser.add_argument(
        '--cli',
        action='store_true',
        help='Run in command-line mode (no GUI)'
    )
    
    args = parser.parse_args()
    
    if args.cli:
        # Command-line mode
        scanner = NetworkScanner()
        ports = [int(p.strip()) for p in args.ports.split(',')]
        
        print(f"Scanning network: {args.target}")
        print(f"Scanning ports: {ports}")
        print("Starting scan...")
        
        def cli_callback(message):
            print(message)
        
        scanner.scan_network(args.target, ports, cli_callback)
        
        print(f"\nScan completed! Found {len(scanner.results)} active hosts:")
        for result in scanner.results:
            print(f"Host: {result['ip']} ({result['hostname']})")
            if result['ports']:
                print(f"  Open Ports: {', '.join(map(str, result['ports']))}")
    else:
        # GUI mode
        root = tk.Tk()
        app = NetworkScannerGUI(root)
        
        # Set initial values from command line
        app.target_var.set(args.target)
        app.ports_var.set(args.ports)
        
        root.mainloop()


if __name__ == "__main__":
    main()
