#!/usr/bin/env python3
"""
CVE Lookup and Information Script

This script allows users to query CVE (Common Vulnerabilities and Exposures) 
information from the National Vulnerability Database (NVD) API.

Usage:
    python cve_lookup.py CVE-2021-44228
    python cve_lookup.py CVE-2021-44228 --format json
    python cve_lookup.py --search "apache log4j" --limit 5
    python cve_lookup.py --recent 10

Author: Security Research Tool
License: MIT
"""

import argparse
import json
import sys
import urllib.request
import urllib.parse
import urllib.error
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import time


class CVELookup:
    """
    A class to handle CVE lookups and information retrieval from NVD API.
    """
    
    def __init__(self):
        """Initialize the CVE lookup client."""
        self.base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.headers = {
            'User-Agent': 'CVE-Lookup-Script/1.0',
            'Accept': 'application/json'
        }
        
    def validate_cve_id(self, cve_id: str) -> bool:
        """
        Validate CVE ID format (CVE-YYYY-NNNN or CVE-YYYY-NNNNN).
        
        Args:
            cve_id (str): The CVE ID to validate
            
        Returns:
            bool: True if valid format, False otherwise
        """
        import re
        pattern = r'^CVE-\d{4}-\d{4,}$'
        return bool(re.match(pattern, cve_id.upper()))
    
    def make_request(self, url: str) -> Optional[Dict[str, Any]]:
        """
        Make HTTP request to NVD API with error handling.
        
        Args:
            url (str): The URL to request
            
        Returns:
            Optional[Dict]: JSON response or None if error
        """
        try:
            request = urllib.request.Request(url, headers=self.headers)
            with urllib.request.urlopen(request, timeout=30) as response:
                if response.status == 200:
                    data = json.loads(response.read().decode('utf-8'))
                    return data
                else:
                    print(f"Error: HTTP {response.status}")
                    return None
                    
        except urllib.error.HTTPError as e:
            if e.code == 404:
                print(f"Error: CVE not found (404)")
            elif e.code == 429:
                print(f"Error: Rate limit exceeded (429). Please wait and try again.")
            else:
                print(f"Error: HTTP {e.code} - {e.reason}")
            return None
            
        except urllib.error.URLError as e:
            print(f"Error: Network error - {e.reason}")
            return None
            
        except json.JSONDecodeError:
            print("Error: Invalid JSON response")
            return None
            
        except Exception as e:
            print(f"Error: Unexpected error - {e}")
            return None
    
    def lookup_cve(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """
        Look up a specific CVE by ID.
        
        Args:
            cve_id (str): The CVE ID to look up
            
        Returns:
            Optional[Dict]: CVE data or None if not found
        """
        if not self.validate_cve_id(cve_id):
            print(f"Error: Invalid CVE ID format: {cve_id}")
            return None
            
        url = f"{self.base_url}?cveId={cve_id.upper()}"
        data = self.make_request(url)
        
        if data and data.get('vulnerabilities'):
            return data['vulnerabilities'][0]['cve']
        return None
    
    def search_cves(self, keyword: str, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Search for CVEs by keyword.
        
        Args:
            keyword (str): Search keyword
            limit (int): Maximum number of results
            
        Returns:
            List[Dict]: List of CVE data
        """
        encoded_keyword = urllib.parse.quote(keyword)
        url = f"{self.base_url}?keywordSearch={encoded_keyword}&resultsPerPage={min(limit, 2000)}"
        
        data = self.make_request(url)
        
        if data and data.get('vulnerabilities'):
            return [vuln['cve'] for vuln in data['vulnerabilities'][:limit]]
        return []
    
    def get_recent_cves(self, days: int = 7, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get recently published CVEs.
        
        Args:
            days (int): Number of days back to search
            limit (int): Maximum number of results
            
        Returns:
            List[Dict]: List of recent CVE data
        """
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        start_str = start_date.strftime('%Y-%m-%dT%H:%M:%S.000')
        end_str = end_date.strftime('%Y-%m-%dT%H:%M:%S.000')
        
        url = f"{self.base_url}?pubStartDate={start_str}&pubEndDate={end_str}&resultsPerPage={min(limit, 2000)}"
        
        data = self.make_request(url)
        
        if data and data.get('vulnerabilities'):
            return [vuln['cve'] for vuln in data['vulnerabilities'][:limit]]
        return []


def format_cve_output(cve_data: Dict[str, Any], output_format: str = 'text') -> str:
    """
    Format CVE data for display.
    
    Args:
        cve_data (Dict): CVE data from API
        output_format (str): Output format ('text' or 'json')
        
    Returns:
        str: Formatted output
    """
    if output_format.lower() == 'json':
        return json.dumps(cve_data, indent=2)
    
    # Text format
    output = []
    output.append(f"CVE ID: {cve_data.get('id', 'N/A')}")
    output.append(f"Published: {cve_data.get('published', 'N/A')}")
    output.append(f"Last Modified: {cve_data.get('lastModified', 'N/A')}")
    
    # Description
    descriptions = cve_data.get('descriptions', [])
    if descriptions:
        eng_desc = next((desc['value'] for desc in descriptions if desc['lang'] == 'en'), 'N/A')
        output.append(f"Description: {eng_desc}")
    
    # CVSS scores
    metrics = cve_data.get('metrics', {})
    if 'cvssMetricV31' in metrics:
        cvss = metrics['cvssMetricV31'][0]['cvssData']
        output.append(f"CVSS v3.1 Score: {cvss.get('baseScore', 'N/A')} ({cvss.get('baseSeverity', 'N/A')})")
    elif 'cvssMetricV30' in metrics:
        cvss = metrics['cvssMetricV30'][0]['cvssData']
        output.append(f"CVSS v3.0 Score: {cvss.get('baseScore', 'N/A')} ({cvss.get('baseSeverity', 'N/A')})")
    elif 'cvssMetricV2' in metrics:
        cvss = metrics['cvssMetricV2'][0]['cvssData']
        output.append(f"CVSS v2 Score: {cvss.get('baseScore', 'N/A')}")
    
    # References
    references = cve_data.get('references', [])
    if references:
        output.append("References:")
        for ref in references[:5]:  # Limit to first 5 references
            output.append(f"  - {ref.get('url', 'N/A')}")
        if len(references) > 5:
            output.append(f"  ... and {len(references) - 5} more")
    
    output.append("-" * 80)
    return '\n'.join(output)


def main():
    """Main function to handle command line arguments and execute CVE lookups."""
    parser = argparse.ArgumentParser(
        description='CVE Lookup and Information Script',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  %(prog)s CVE-2021-44228
  %(prog)s CVE-2021-44228 --format json
  %(prog)s --search "apache log4j" --limit 5
  %(prog)s --recent 10
        '''
    )
    
    # Main argument groups
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('cve_id', nargs='?', help='CVE ID to lookup (e.g., CVE-2021-44228)')
    group.add_argument('--search', '-s', help='Search CVEs by keyword')
    group.add_argument('--recent', '-r', type=int, metavar='DAYS', 
                      help='Get CVEs published in the last N days')
    
    # Optional arguments
    parser.add_argument('--format', '-f', choices=['text', 'json'], default='text',
                       help='Output format (default: text)')
    parser.add_argument('--limit', '-l', type=int, default=10, metavar='N',
                       help='Limit number of results (default: 10)')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Enable verbose output')
    
    args = parser.parse_args()
    
    # Initialize CVE lookup client
    cve_client = CVELookup()
    
    try:
        if args.cve_id:
            # Single CVE lookup
            if args.verbose:
                print(f"Looking up CVE: {args.cve_id}")
            
            cve_data = cve_client.lookup_cve(args.cve_id)
            if cve_data:
                print(format_cve_output(cve_data, args.format))
            else:
                print(f"CVE {args.cve_id} not found or error occurred.")
                sys.exit(1)
                
        elif args.search:
            # Keyword search
            if args.verbose:
                print(f"Searching for: {args.search} (limit: {args.limit})")
            
            results = cve_client.search_cves(args.search, args.limit)
            if results:
                print(f"Found {len(results)} CVE(s) matching '{args.search}':\n")
                for cve_data in results:
                    print(format_cve_output(cve_data, args.format))
            else:
                print(f"No CVEs found matching '{args.search}'.")
                
        elif args.recent:
            # Recent CVEs
            if args.verbose:
                print(f"Getting CVEs from last {args.recent} days (limit: {args.limit})")
            
            results = cve_client.get_recent_cves(args.recent, args.limit)
            if results:
                print(f"Found {len(results)} recent CVE(s):\n")
                for cve_data in results:
                    print(format_cve_output(cve_data, args.format))
            else:
                print(f"No recent CVEs found in the last {args.recent} days.")
                
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
