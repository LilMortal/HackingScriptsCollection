#!/usr/bin/env python3
"""
Network Monitoring Utility

A comprehensive network monitoring tool that tracks connectivity, response times,
and network statistics for specified hosts.

Usage Examples:
    python network_monitor.py google.com
    python network_monitor.py -t 192.168.1.1 -i 2 -c 10
    python network_monitor.py -t example.com cloudflare.com -p 80 443 -o results.json
    python network_monitor.py --help

Author: Network Monitoring Script
License: MIT
"""

import argparse
import json
import logging
import socket
import statistics
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)


class NetworkMonitor:
    """
    A network monitoring utility that tracks connectivity and performance metrics.
    """
    
    def __init__(self, targets: List[str], ports: List[int] = None, 
                 interval: float = 1.0, timeout: float = 5.0):
        """
        Initialize the network monitor.
        
        Args:
            targets: List of hostnames or IP addresses to monitor
            ports: List of ports to check (default: [80, 443])
            interval: Time between checks in seconds
            timeout: Socket timeout in seconds
        """
        self.targets = targets
        self.ports = ports or [80, 443]
        self.interval = interval
        self.timeout = timeout
        self.results = {}
        self.start_time = datetime.now()
        
        # Initialize results structure
        for target in self.targets:
            self.results[target] = {
                'ping_times': [],
                'port_checks': {port: [] for port in self.ports},
                'errors': [],
                'total_checks': 0,
                'successful_checks': 0
            }
    
    def resolve_hostname(self, hostname: str) -> Optional[str]:
        """
        Resolve hostname to IP address.
        
        Args:
            hostname: Hostname to resolve
            
        Returns:
            IP address string or None if resolution fails
        """
        try:
            ip_address = socket.gethostbyname(hostname)
            logger.debug(f"Resolved {hostname} to {ip_address}")
            return ip_address
        except socket.gaierror as e:
            logger.error(f"Failed to resolve {hostname}: {e}")
            return None
    
    def check_tcp_connection(self, host: str, port: int) -> Tuple[bool, float]:
        """
        Check TCP connection to a specific host and port.
        
        Args:
            host: Hostname or IP address
            port: Port number
            
        Returns:
            Tuple of (success: bool, response_time: float)
        """
        start_time = time.time()
        
        try:
            # Create socket and attempt connection
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            
            result = sock.connect_ex((host, port))
            sock.close()
            
            response_time = (time.time() - start_time) * 1000  # Convert to milliseconds
            
            if result == 0:
                logger.debug(f"Successfully connected to {host}:{port} in {response_time:.2f}ms")
                return True, response_time
            else:
                logger.debug(f"Failed to connect to {host}:{port}")
                return False, response_time
                
        except socket.timeout:
            response_time = (time.time() - start_time) * 1000
            logger.debug(f"Connection to {host}:{port} timed out after {response_time:.2f}ms")
            return False, response_time
        except Exception as e:
            response_time = (time.time() - start_time) * 1000
            logger.error(f"Error connecting to {host}:{port}: {e}")
            return False, response_time
    
    def ping_host(self, host: str) -> Tuple[bool, float]:
        """
        Simulate a ping by attempting a quick TCP connection.
        
        Args:
            host: Hostname or IP address
            
        Returns:
            Tuple of (success: bool, response_time: float)
        """
        # Use the first available port for ping simulation
        return self.check_tcp_connection(host, self.ports[0])
    
    def monitor_target(self, target: str) -> Dict:
        """
        Monitor a single target and collect metrics.
        
        Args:
            target: Hostname or IP address to monitor
            
        Returns:
            Dictionary containing monitoring results
        """
        target_results = self.results[target]
        target_results['total_checks'] += 1
        
        # Resolve hostname if necessary
        resolved_ip = self.resolve_hostname(target)
        if not resolved_ip:
            error_msg = f"Failed to resolve hostname: {target}"
            target_results['errors'].append({
                'timestamp': datetime.now().isoformat(),
                'error': error_msg
            })
            return target_results
        
        # Perform ping test
        ping_success, ping_time = self.ping_host(resolved_ip)
        target_results['ping_times'].append({
            'timestamp': datetime.now().isoformat(),
            'success': ping_success,
            'response_time_ms': ping_time
        })
        
        # Check each specified port
        all_ports_success = True
        for port in self.ports:
            port_success, port_time = self.check_tcp_connection(resolved_ip, port)
            target_results['port_checks'][port].append({
                'timestamp': datetime.now().isoformat(),
                'success': port_success,
                'response_time_ms': port_time
            })
            
            if not port_success:
                all_ports_success = False
        
        # Update success counter
        if ping_success and all_ports_success:
            target_results['successful_checks'] += 1
        
        return target_results
    
    def calculate_statistics(self, target: str) -> Dict:
        """
        Calculate statistics for a monitored target.
        
        Args:
            target: Target hostname/IP
            
        Returns:
            Dictionary containing calculated statistics
        """
        target_data = self.results[target]
        
        # Calculate ping statistics
        successful_pings = [p for p in target_data['ping_times'] if p['success']]
        ping_times = [p['response_time_ms'] for p in successful_pings]
        
        ping_stats = {}
        if ping_times:
            ping_stats = {
                'min_ms': min(ping_times),
                'max_ms': max(ping_times),
                'avg_ms': statistics.mean(ping_times),
                'median_ms': statistics.median(ping_times)
            }
        
        # Calculate port statistics
        port_stats = {}
        for port in self.ports:
            successful_connections = [p for p in target_data['port_checks'][port] if p['success']]
            connection_times = [p['response_time_ms'] for p in successful_connections]
            
            if connection_times:
                port_stats[port] = {
                    'success_rate': len(successful_connections) / len(target_data['port_checks'][port]),
                    'avg_response_time_ms': statistics.mean(connection_times)
                }
            else:
                port_stats[port] = {
                    'success_rate': 0.0,
                    'avg_response_time_ms': 0.0
                }
        
        return {
            'target': target,
            'total_checks': target_data['total_checks'],
            'successful_checks': target_data['successful_checks'],
            'success_rate': target_data['successful_checks'] / target_data['total_checks'] if target_data['total_checks'] > 0 else 0,
            'ping_statistics': ping_stats,
            'port_statistics': port_stats,
            'error_count': len(target_data['errors'])
        }
    
    def display_live_stats(self):
        """Display live monitoring statistics."""
        print(f"\n{'='*60}")
        print(f"Network Monitor - Live Statistics")
        print(f"Started: {self.start_time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"{'='*60}")
        
        for target in self.targets:
            stats = self.calculate_statistics(target)
            print(f"\nTarget: {target}")
            print(f"  Total Checks: {stats['total_checks']}")
            print(f"  Success Rate: {stats['success_rate']:.2%}")
            
            if stats['ping_statistics']:
                ping_stats = stats['ping_statistics']
                print(f"  Ping: {ping_stats['avg_ms']:.2f}ms avg, {ping_stats['min_ms']:.2f}ms min, {ping_stats['max_ms']:.2f}ms max")
            
            for port, port_stats in stats['port_statistics'].items():
                print(f"  Port {port}: {port_stats['success_rate']:.2%} success, {port_stats['avg_response_time_ms']:.2f}ms avg")
            
            if stats['error_count'] > 0:
                print(f"  Errors: {stats['error_count']}")
    
    def save_results(self, output_file: str):
        """
        Save monitoring results to a JSON file.
        
        Args:
            output_file: Path to output file
        """
        try:
            # Prepare final results with statistics
            final_results = {
                'monitoring_session': {
                    'start_time': self.start_time.isoformat(),
                    'end_time': datetime.now().isoformat(),
                    'targets': self.targets,
                    'ports': self.ports,
                    'interval': self.interval,
                    'timeout': self.timeout
                },
                'statistics': {},
                'raw_data': self.results
            }
            
            # Add statistics for each target
            for target in self.targets:
                final_results['statistics'][target] = self.calculate_statistics(target)
            
            # Write to file
            with open(output_file, 'w') as f:
                json.dump(final_results, f, indent=2)
            
            logger.info(f"Results saved to {output_file}")
            
        except Exception as e:
            logger.error(f"Failed to save results: {e}")
    
    def run(self, count: Optional[int] = None, output_file: Optional[str] = None):
        """
        Run the network monitoring loop.
        
        Args:
            count: Number of checks to perform (None for infinite)
            output_file: File to save results to
        """
        logger.info(f"Starting network monitoring for targets: {', '.join(self.targets)}")
        logger.info(f"Monitoring ports: {', '.join(map(str, self.ports))}")
        logger.info(f"Check interval: {self.interval}s, Timeout: {self.timeout}s")
        
        if count:
            logger.info(f"Will perform {count} checks")
        else:
            logger.info("Press Ctrl+C to stop monitoring")
        
        check_count = 0
        
        try:
            while True:
                # Check if we've reached the desired count
                if count and check_count >= count:
                    break
                
                # Monitor all targets
                for target in self.targets:
                    self.monitor_target(target)
                
                check_count += 1
                
                # Display live statistics every 10 checks or on last check
                if check_count % 10 == 0 or (count and check_count == count):
                    self.display_live_stats()
                
                # Wait for next iteration (unless this is the last check)
                if not count or check_count < count:
                    time.sleep(self.interval)
        
        except KeyboardInterrupt:
            logger.info("\nMonitoring stopped by user")
        
        # Display final statistics
        print(f"\n{'='*60}")
        print("Final Statistics")
        print(f"{'='*60}")
        
        for target in self.targets:
            stats = self.calculate_statistics(target)
            print(f"\nTarget: {target}")
            print(f"  Total Checks: {stats['total_checks']}")
            print(f"  Successful Checks: {stats['successful_checks']}")
            print(f"  Success Rate: {stats['success_rate']:.2%}")
            print(f"  Error Count: {stats['error_count']}")
            
            if stats['ping_statistics']:
                ping_stats = stats['ping_statistics']
                print(f"  Ping Statistics:")
                print(f"    Average: {ping_stats['avg_ms']:.2f}ms")
                print(f"    Min: {ping_stats['min_ms']:.2f}ms")
                print(f"    Max: {ping_stats['max_ms']:.2f}ms")
                print(f"    Median: {ping_stats['median_ms']:.2f}ms")
        
        # Save results to file if specified
        if output_file:
            self.save_results(output_file)


def main():
    """Main function to parse arguments and run the network monitor."""
    parser = argparse.ArgumentParser(
        description="Network Monitoring Utility - Monitor network connectivity and performance",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python network_monitor.py google.com
  python network_monitor.py -t 192.168.1.1 -i 2 -c 10
  python network_monitor.py -t example.com cloudflare.com -p 80 443 -o results.json
  python network_monitor.py google.com --timeout 10 --verbose
        """
    )
    
    parser.add_argument(
        'targets',
        nargs='*',
        help='Hostnames or IP addresses to monitor (can also use -t/--targets)'
    )
    
    parser.add_argument(
        '-t', '--targets',
        nargs='+',
        dest='additional_targets',
        help='Additional hostnames or IP addresses to monitor'
    )
    
    parser.add_argument(
        '-p', '--ports',
        nargs='+',
        type=int,
        default=[80, 443],
        help='Ports to check for each target (default: 80 443)'
    )
    
    parser.add_argument(
        '-i', '--interval',
        type=float,
        default=1.0,
        help='Time between checks in seconds (default: 1.0)'
    )
    
    parser.add_argument(
        '-c', '--count',
        type=int,
        help='Number of checks to perform (default: infinite)'
    )
    
    parser.add_argument(
        '--timeout',
        type=float,
        default=5.0,
        help='Connection timeout in seconds (default: 5.0)'
    )
    
    parser.add_argument(
        '-o', '--output',
        help='Save results to JSON file'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose logging'
    )
    
    args = parser.parse_args()
    
    # Set logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Combine targets from positional and optional arguments
    all_targets = args.targets or []
    if args.additional_targets:
        all_targets.extend(args.additional_targets)
    
    # Validate arguments
    if not all_targets:
        parser.error("At least one target must be specified")
    
    if args.interval <= 0:
        parser.error("Interval must be positive")
    
    if args.timeout <= 0:
        parser.error("Timeout must be positive")
    
    if args.count is not None and args.count <= 0:
        parser.error("Count must be positive")
    
    # Validate ports
    for port in args.ports:
        if not (1 <= port <= 65535):
            parser.error(f"Port {port} is not valid (must be 1-65535)")
    
    # Create and run network monitor
    try:
        monitor = NetworkMonitor(
            targets=all_targets,
            ports=args.ports,
            interval=args.interval,
            timeout=args.timeout
        )
        
        monitor.run(count=args.count, output_file=args.output)
        
    except Exception as e:
        logger.error(f"Network monitoring failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
