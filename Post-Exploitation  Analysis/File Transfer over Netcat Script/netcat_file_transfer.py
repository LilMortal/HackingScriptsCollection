#!/usr/bin/env python3
"""
File Transfer over Netcat Script

A Python utility for transferring files between systems using netcat (nc) as the transport layer.
This script provides both sender and receiver functionality with proper error handling and validation.

Usage Examples:
    # Send a file (sender mode)
    python netcat_transfer.py send --host 192.168.1.100 --port 8080 --file document.pdf

    # Receive a file (receiver mode)
    python netcat_transfer.py receive --port 8080 --output received_file.pdf

    # Send with custom timeout
    python netcat_transfer.py send --host example.com --port 9000 --file data.zip --timeout 60

Author: Generated Script
License: MIT
"""

import argparse
import subprocess
import sys
import os
import time
import signal
import hashlib
from pathlib import Path
from typing import Optional, Tuple


class NetcatTransferError(Exception):
    """Custom exception for netcat transfer operations."""
    pass


class FileTransfer:
    """
    Handles file transfer operations using netcat as the transport mechanism.
    
    This class provides methods for both sending and receiving files over a network
    connection established through netcat (nc).
    """
    
    def __init__(self, timeout: int = 30):
        """
        Initialize the FileTransfer instance.
        
        Args:
            timeout (int): Timeout in seconds for network operations
        """
        self.timeout = timeout
        self.netcat_cmd = self._find_netcat()
    
    def _find_netcat(self) -> str:
        """
        Find the netcat executable on the system.
        
        Returns:
            str: Path to netcat executable
            
        Raises:
            NetcatTransferError: If netcat is not found
        """
        # Common netcat command names across different systems
        nc_variants = ['nc', 'netcat', 'ncat']
        
        for variant in nc_variants:
            try:
                result = subprocess.run(['which', variant], capture_output=True, text=True)
                if result.returncode == 0:
                    return variant
            except FileNotFoundError:
                continue
        
        # Try direct execution as fallback
        for variant in nc_variants:
            try:
                result = subprocess.run([variant, '-h'], capture_output=True, text=True, timeout=5)
                return variant
            except (FileNotFoundError, subprocess.TimeoutExpired):
                continue
        
        raise NetcatTransferError(
            "Netcat (nc) not found on system. Please install netcat:\n"
            "  Ubuntu/Debian: sudo apt-get install netcat\n"
            "  CentOS/RHEL/Fedora: sudo yum install nc\n"
            "  macOS: brew install netcat"
        )
    
    def _calculate_checksum(self, filepath: str) -> str:
        """
        Calculate SHA256 checksum of a file.
        
        Args:
            filepath (str): Path to the file
            
        Returns:
            str: SHA256 hexdigest of the file
        """
        sha256_hash = hashlib.sha256()
        try:
            with open(filepath, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(chunk)
            return sha256_hash.hexdigest()
        except IOError as e:
            raise NetcatTransferError(f"Error calculating checksum: {e}")
    
    def _validate_file_path(self, filepath: str, check_exists: bool = True) -> Path:
        """
        Validate and normalize file path.
        
        Args:
            filepath (str): Path to validate
            check_exists (bool): Whether to check if file exists
            
        Returns:
            Path: Validated Path object
            
        Raises:
            NetcatTransferError: If validation fails
        """
        path = Path(filepath).resolve()
        
        if check_exists and not path.exists():
            raise NetcatTransferError(f"File does not exist: {filepath}")
        
        if check_exists and not path.is_file():
            raise NetcatTransferError(f"Path is not a file: {filepath}")
        
        return path
    
    def _validate_network_params(self, host: Optional[str], port: int) -> None:
        """
        Validate network parameters.
        
        Args:
            host (Optional[str]): Hostname or IP address
            port (int): Port number
            
        Raises:
            NetcatTransferError: If validation fails
        """
        if port < 1 or port > 65535:
            raise NetcatTransferError(f"Invalid port number: {port}. Must be between 1-65535")
        
        if host and len(host.strip()) == 0:
            raise NetcatTransferError("Host cannot be empty")
    
    def send_file(self, filepath: str, host: str, port: int, show_progress: bool = True) -> bool:
        """
        Send a file to a remote host using netcat.
        
        Args:
            filepath (str): Path to the file to send
            host (str): Target hostname or IP address
            port (int): Target port number
            show_progress (bool): Whether to show transfer progress
            
        Returns:
            bool: True if transfer was successful
            
        Raises:
            NetcatTransferError: If transfer fails
        """
        # Validate inputs
        file_path = self._validate_file_path(filepath)
        self._validate_network_params(host, port)
        
        # Get file information
        file_size = file_path.stat().st_size
        checksum = self._calculate_checksum(str(file_path))
        
        print(f"Preparing to send: {file_path.name}")
        print(f"File size: {file_size:,} bytes")
        print(f"SHA256 checksum: {checksum}")
        print(f"Target: {host}:{port}")
        print("-" * 50)
        
        # Construct netcat command for sending
        nc_cmd = [
            self.netcat_cmd,
            '-w', str(self.timeout),  # Set timeout
            host,
            str(port)
        ]
        
        try:
            # Start netcat process
            print("Establishing connection...")
            with open(file_path, 'rb') as file:
                process = subprocess.Popen(
                    nc_cmd,
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
                
                # Send file in chunks
                bytes_sent = 0
                chunk_size = 8192
                
                while True:
                    chunk = file.read(chunk_size)
                    if not chunk:
                        break
                    
                    process.stdin.write(chunk)
                    bytes_sent += len(chunk)
                    
                    if show_progress:
                        progress = (bytes_sent / file_size) * 100
                        print(f"\rProgress: {progress:.1f}% ({bytes_sent:,}/{file_size:,} bytes)", end='', flush=True)
                
                # Close stdin to signal end of transmission
                process.stdin.close()
                
                # Wait for process to complete
                stdout, stderr = process.communicate(timeout=self.timeout)
                
                if show_progress:
                    print()  # New line after progress
                
                if process.returncode == 0:
                    print("✓ File sent successfully!")
                    return True
                else:
                    error_msg = stderr.decode('utf-8', errors='ignore').strip()
                    raise NetcatTransferError(f"Transfer failed: {error_msg}")
        
        except subprocess.TimeoutExpired:
            process.kill()
            raise NetcatTransferError(f"Transfer timed out after {self.timeout} seconds")
        except KeyboardInterrupt:
            process.kill()
            raise NetcatTransferError("Transfer cancelled by user")
        except Exception as e:
            raise NetcatTransferError(f"Unexpected error during transfer: {e}")
    
    def receive_file(self, port: int, output_path: str, show_progress: bool = True) -> bool:
        """
        Receive a file using netcat.
        
        Args:
            port (int): Port to listen on
            output_path (str): Path where received file will be saved
            show_progress (bool): Whether to show transfer progress
            
        Returns:
            bool: True if transfer was successful
            
        Raises:
            NetcatTransferError: If transfer fails
        """
        # Validate inputs
        self._validate_network_params(None, port)
        output_file = Path(output_path).resolve()
        
        # Check if output directory exists
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Warn if file already exists
        if output_file.exists():
            response = input(f"File {output_file} already exists. Overwrite? (y/N): ")
            if response.lower() != 'y':
                print("Transfer cancelled.")
                return False
        
        print(f"Listening on port {port}...")
        print(f"Output file: {output_file}")
        print("Waiting for connection...")
        print("-" * 50)
        
        # Construct netcat command for receiving
        nc_cmd = [
            self.netcat_cmd,
            '-l',  # Listen mode
            '-p', str(port),  # Port
            '-w', str(self.timeout)  # Timeout
        ]
        
        try:
            # Start netcat process
            process = subprocess.Popen(
                nc_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            print("Connection established. Receiving data...")
            
            # Receive data and write to file
            bytes_received = 0
            chunk_size = 8192
            
            with open(output_file, 'wb') as file:
                while True:
                    chunk = process.stdout.read(chunk_size)
                    if not chunk:
                        break
                    
                    file.write(chunk)
                    bytes_received += len(chunk)
                    
                    if show_progress:
                        print(f"\rReceived: {bytes_received:,} bytes", end='', flush=True)
            
            # Wait for process to complete
            process.wait(timeout=self.timeout)
            
            if show_progress:
                print()  # New line after progress
            
            if bytes_received > 0:
                checksum = self._calculate_checksum(str(output_file))
                print("✓ File received successfully!")
                print(f"Bytes received: {bytes_received:,}")
                print(f"SHA256 checksum: {checksum}")
                return True
            else:
                output_file.unlink(missing_ok=True)  # Remove empty file
                raise NetcatTransferError("No data received")
        
        except subprocess.TimeoutExpired:
            process.kill()
            raise NetcatTransferError(f"Transfer timed out after {self.timeout} seconds")
        except KeyboardInterrupt:
            process.kill()
            output_file.unlink(missing_ok=True)  # Clean up partial file
            raise NetcatTransferError("Transfer cancelled by user")
        except Exception as e:
            output_file.unlink(missing_ok=True)  # Clean up partial file
            raise NetcatTransferError(f"Unexpected error during transfer: {e}")


def create_argument_parser() -> argparse.ArgumentParser:
    """
    Create and configure the command-line argument parser.
    
    Returns:
        argparse.ArgumentParser: Configured argument parser
    """
    parser = argparse.ArgumentParser(
        description="Transfer files between systems using netcat",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Send a file
  %(prog)s send --host 192.168.1.100 --port 8080 --file document.pdf
  
  # Receive a file
  %(prog)s receive --port 8080 --output received_file.pdf
  
  # Send with custom timeout
  %(prog)s send --host example.com --port 9000 --file data.zip --timeout 60
        """.strip()
    )
    
    # Create subparsers for send/receive modes
    subparsers = parser.add_subparsers(dest='mode', help='Transfer mode')
    subparsers.required = True
    
    # Send mode parser
    send_parser = subparsers.add_parser('send', help='Send a file to remote host')
    send_parser.add_argument('--host', '-H', required=True,
                           help='Target hostname or IP address')
    send_parser.add_argument('--port', '-p', type=int, required=True,
                           help='Target port number (1-65535)')
    send_parser.add_argument('--file', '-f', required=True,
                           help='Path to file to send')
    send_parser.add_argument('--timeout', '-t', type=int, default=30,
                           help='Timeout in seconds (default: 30)')
    send_parser.add_argument('--quiet', '-q', action='store_true',
                           help='Suppress progress output')
    
    # Receive mode parser
    recv_parser = subparsers.add_parser('receive', help='Receive a file from remote host')
    recv_parser.add_argument('--port', '-p', type=int, required=True,
                           help='Port to listen on (1-65535)')
    recv_parser.add_argument('--output', '-o', required=True,
                           help='Output file path')
    recv_parser.add_argument('--timeout', '-t', type=int, default=30,
                           help='Timeout in seconds (default: 30)')
    recv_parser.add_argument('--quiet', '-q', action='store_true',
                           help='Suppress progress output')
    
    return parser


def main() -> int:
    """
    Main function to handle command-line execution.
    
    Returns:
        int: Exit code (0 for success, 1 for error)
    """
    parser = create_argument_parser()
    args = parser.parse_args()
    
    try:
        # Create file transfer instance
        transfer = FileTransfer(timeout=args.timeout)
        
        # Execute based on mode
        if args.mode == 'send':
            success = transfer.send_file(
                filepath=args.file,
                host=args.host,
                port=args.port,
                show_progress=not args.quiet
            )
        elif args.mode == 'receive':
            success = transfer.receive_file(
                port=args.port,
                output_path=args.output,
                show_progress=not args.quiet
            )
        else:
            print(f"Unknown mode: {args.mode}", file=sys.stderr)
            return 1
        
        return 0 if success else 1
    
    except NetcatTransferError as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        return 1


if __name__ == '__main__':
    sys.exit(main())