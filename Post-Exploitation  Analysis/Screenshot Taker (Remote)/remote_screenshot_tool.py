#!/usr/bin/env python3
"""
Screenshot Taker (Remote) - A tool for taking screenshots on remote systems via SSH

This script connects to remote systems via SSH and captures screenshots using
various methods depending on the remote system's capabilities.

Usage:
    python screenshot_taker_remote.py -H hostname -u username -p password
    python screenshot_taker_remote.py -H hostname -u username -k ~/.ssh/id_rsa
    python screenshot_taker_remote.py -H hostname -u username --port 2222 -o /path/to/save/

Author: Assistant
License: MIT
Version: 1.0.0
"""

import argparse
import os
import sys
import time
import logging
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple

try:
    import paramiko
    from scp import SCPClient
except ImportError:
    print("Required dependencies not installed. Please run:")
    print("pip install paramiko scp")
    sys.exit(1)


class RemoteScreenshotTaker:
    """
    A class to handle remote screenshot operations via SSH.
    
    This class provides methods to connect to remote systems, execute screenshot
    commands, and transfer the captured images back to the local system.
    """
    
    def __init__(self, hostname: str, username: str, password: str = None, 
                 key_filename: str = None, port: int = 22, timeout: int = 30):
        """
        Initialize the RemoteScreenshotTaker.
        
        Args:
            hostname (str): Remote host IP address or hostname
            username (str): SSH username
            password (str, optional): SSH password
            key_filename (str, optional): Path to SSH private key file
            port (int): SSH port (default: 22)
            timeout (int): Connection timeout in seconds (default: 30)
        """
        self.hostname = hostname
        self.username = username
        self.password = password
        self.key_filename = key_filename
        self.port = port
        self.timeout = timeout
        self.ssh_client = None
        self.scp_client = None
        
        # Set up logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
    
    def connect(self) -> bool:
        """
        Establish SSH connection to the remote host.
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            # Connection parameters
            connect_kwargs = {
                'hostname': self.hostname,
                'username': self.username,
                'port': self.port,
                'timeout': self.timeout
            }
            
            # Add authentication method
            if self.key_filename:
                connect_kwargs['key_filename'] = self.key_filename
                self.logger.info(f"Connecting to {self.hostname} using key file: {self.key_filename}")
            elif self.password:
                connect_kwargs['password'] = self.password
                self.logger.info(f"Connecting to {self.hostname} using password authentication")
            else:
                self.logger.error("No authentication method provided (password or key file)")
                return False
            
            # Establish connection
            self.ssh_client.connect(**connect_kwargs)
            self.scp_client = SCPClient(self.ssh_client.get_transport())
            
            self.logger.info(f"Successfully connected to {self.hostname}")
            return True
            
        except paramiko.AuthenticationException:
            self.logger.error("Authentication failed")
            return False
        except paramiko.SSHException as e:
            self.logger.error(f"SSH connection error: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Unexpected error during connection: {e}")
            return False
    
    def disconnect(self):
        """Close SSH and SCP connections."""
        if self.scp_client:
            self.scp_client.close()
        if self.ssh_client:
            self.ssh_client.close()
        self.logger.info("Disconnected from remote host")
    
    def detect_screenshot_method(self) -> str:
        """
        Detect the best available screenshot method on the remote system.
        
        Returns:
            str: The screenshot command to use
        """
        # List of screenshot tools to try, in order of preference
        screenshot_tools = [
            ('scrot', 'scrot'),
            ('gnome-screenshot', 'gnome-screenshot'),
            ('import', 'import'),  # ImageMagick
            ('xwd', 'xwd'),
            ('screencapture', 'screencapture'),  # macOS
        ]
        
        for tool_name, tool_cmd in screenshot_tools:
            try:
                stdin, stdout, stderr = self.ssh_client.exec_command(f"which {tool_name}")
                if stdout.read().decode().strip():
                    self.logger.info(f"Found screenshot tool: {tool_name}")
                    return self._get_screenshot_command(tool_name)
            except Exception as e:
                self.logger.debug(f"Error checking for {tool_name}: {e}")
                continue
        
        # If no tools found, return a generic command
        self.logger.warning("No screenshot tools detected, trying generic approach")
        return "scrot"
    
    def _get_screenshot_command(self, tool: str) -> str:
        """
        Get the appropriate screenshot command for the detected tool.
        
        Args:
            tool (str): Name of the screenshot tool
            
        Returns:
            str: Complete screenshot command
        """
        commands = {
            'scrot': 'scrot',
            'gnome-screenshot': 'gnome-screenshot -f',
            'import': 'import -window root',
            'xwd': 'xwd -root | convert xwd:- png:-',
            'screencapture': 'screencapture',
        }
        return commands.get(tool, 'scrot')
    
    def take_screenshot(self, output_path: str = None, 
                       remote_filename: str = None) -> Tuple[bool, str]:
        """
        Take a screenshot on the remote system and download it.
        
        Args:
            output_path (str, optional): Local directory to save screenshot
            remote_filename (str, optional): Remote filename for screenshot
            
        Returns:
            Tuple[bool, str]: (Success status, local file path or error message)
        """
        if not self.ssh_client:
            return False, "Not connected to remote host"
        
        # Generate filenames
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        if not remote_filename:
            remote_filename = f"screenshot_{timestamp}.png"
        
        remote_path = f"/tmp/{remote_filename}"
        
        if not output_path:
            output_path = os.getcwd()
        
        local_path = os.path.join(output_path, f"{self.hostname}_{remote_filename}")
        
        try:
            # Detect and prepare screenshot command
            screenshot_cmd = self.detect_screenshot_method()
            full_cmd = f"{screenshot_cmd} {remote_path}"
            
            self.logger.info(f"Taking screenshot with command: {full_cmd}")
            
            # Execute screenshot command
            stdin, stdout, stderr = self.ssh_client.exec_command(full_cmd)
            
            # Wait for command completion
            exit_status = stdout.channel.recv_exit_status()
            
            if exit_status != 0:
                error_msg = stderr.read().decode().strip()
                self.logger.error(f"Screenshot command failed: {error_msg}")
                return False, f"Screenshot command failed: {error_msg}"
            
            # Small delay to ensure file is written
            time.sleep(1)
            
            # Check if file exists on remote system
            stdin, stdout, stderr = self.ssh_client.exec_command(f"ls -la {remote_path}")
            if stdout.channel.recv_exit_status() != 0:
                return False, f"Screenshot file not created at {remote_path}"
            
            # Download the screenshot
            self.logger.info(f"Downloading screenshot from {remote_path} to {local_path}")
            self.scp_client.get(remote_path, local_path)
            
            # Clean up remote file (optional)
            self.ssh_client.exec_command(f"rm {remote_path}")
            
            self.logger.info(f"Screenshot saved successfully: {local_path}")
            return True, local_path
            
        except Exception as e:
            self.logger.error(f"Error taking screenshot: {e}")
            return False, str(e)


def validate_args(args) -> bool:
    """
    Validate command line arguments.
    
    Args:
        args: Parsed command line arguments
        
    Returns:
        bool: True if arguments are valid, False otherwise
    """
    # Check if authentication method is provided
    if not args.password and not args.key_file:
        print("Error: Either password (-p) or key file (-k) must be provided")
        return False
    
    # Check if key file exists
    if args.key_file and not os.path.exists(args.key_file):
        print(f"Error: Key file not found: {args.key_file}")
        return False
    
    # Check if output directory exists
    if args.output and not os.path.exists(args.output):
        try:
            os.makedirs(args.output, exist_ok=True)
        except Exception as e:
            print(f"Error: Cannot create output directory {args.output}: {e}")
            return False
    
    return True


def main():
    """Main function to handle command line arguments and execute screenshot operations."""
    parser = argparse.ArgumentParser(
        description="Take screenshots on remote systems via SSH",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Using password authentication
    python screenshot_taker_remote.py -H 192.168.1.100 -u admin -p password123
    
    # Using SSH key authentication
    python screenshot_taker_remote.py -H server.example.com -u user -k ~/.ssh/id_rsa
    
    # Custom port and output directory
    python screenshot_taker_remote.py -H 192.168.1.100 -u admin -p password123 --port 2222 -o ./screenshots/
    
    # Multiple screenshots with interval
    python screenshot_taker_remote.py -H 192.168.1.100 -u admin -p password123 --count 5 --interval 10
        """
    )
    
    # Required arguments
    parser.add_argument('-H', '--hostname', required=True,
                        help='Remote host IP address or hostname')
    parser.add_argument('-u', '--username', required=True,
                        help='SSH username')
    
    # Authentication (mutually exclusive group would be better, but this is simpler)
    parser.add_argument('-p', '--password',
                        help='SSH password')
    parser.add_argument('-k', '--key-file',
                        help='Path to SSH private key file')
    
    # Optional arguments
    parser.add_argument('--port', type=int, default=22,
                        help='SSH port (default: 22)')
    parser.add_argument('-o', '--output', default=None,
                        help='Output directory for screenshots (default: current directory)')
    parser.add_argument('--timeout', type=int, default=30,
                        help='Connection timeout in seconds (default: 30)')
    parser.add_argument('--count', type=int, default=1,
                        help='Number of screenshots to take (default: 1)')
    parser.add_argument('--interval', type=int, default=0,
                        help='Interval between screenshots in seconds (default: 0)')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Enable verbose logging')
    
    args = parser.parse_args()
    
    # Set logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Validate arguments
    if not validate_args(args):
        sys.exit(1)
    
    # Create RemoteScreenshotTaker instance
    screenshot_taker = RemoteScreenshotTaker(
        hostname=args.hostname,
        username=args.username,
        password=args.password,
        key_filename=args.key_file,
        port=args.port,
        timeout=args.timeout
    )
    
    try:
        # Connect to remote host
        if not screenshot_taker.connect():
            print("Failed to connect to remote host")
            sys.exit(1)
        
        # Take screenshots
        successful_screenshots = 0
        for i in range(args.count):
            if i > 0 and args.interval > 0:
                print(f"Waiting {args.interval} seconds before next screenshot...")
                time.sleep(args.interval)
            
            print(f"Taking screenshot {i + 1}/{args.count}...")
            success, result = screenshot_taker.take_screenshot(output_path=args.output)
            
            if success:
                print(f"Screenshot saved: {result}")
                successful_screenshots += 1
            else:
                print(f"Failed to take screenshot: {result}")
        
        print(f"\nCompleted: {successful_screenshots}/{args.count} screenshots taken successfully")
        
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
    except Exception as e:
        print(f"Unexpected error: {e}")
        sys.exit(1)
    finally:
        screenshot_taker.disconnect()


if __name__ == "__main__":
    main()