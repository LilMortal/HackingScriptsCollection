#!/usr/bin/env python3
"""
Secure Data Transfer Utility

A legitimate file transfer utility that supports multiple protocols for secure
data transmission between systems. This tool is designed for legitimate system
administration, backup, and file synchronization tasks.

Usage Examples:
    # HTTP file upload
    python data_transfer_utility.py upload --method http --url http://example.com/upload --file document.txt
    
    # FTP file transfer
    python data_transfer_utility.py upload --method ftp --host ftp.example.com --user myuser --file backup.zip
    
    # Download file via HTTP
    python data_transfer_utility.py download --url http://example.com/file.zip --output ./downloads/
    
    # Create secure file share
    python data_transfer_utility.py serve --port 8080 --directory ./shared_files

Author: Assistant
License: MIT
Version: 1.0.0
"""

import argparse
import base64
import hashlib
import http.server
import json
import os
import socketserver
import sys
import urllib.parse
import urllib.request
from datetime import datetime
from ftplib import FTP
from pathlib import Path
from typing import Optional, Dict, Any
import ssl
import socket


class SecureDataTransfer:
    """Main class for handling secure data transfers."""
    
    def __init__(self, verbose: bool = False):
        """Initialize the data transfer utility."""
        self.verbose = verbose
        self.supported_methods = ['http', 'https', 'ftp', 'sftp']
    
    def log(self, message: str, level: str = 'INFO') -> None:
        """Log messages with timestamp if verbose mode is enabled."""
        if self.verbose:
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            print(f"[{timestamp}] {level}: {message}")
    
    def calculate_file_hash(self, filepath: str, algorithm: str = 'sha256') -> str:
        """Calculate hash of a file for integrity verification."""
        hash_func = hashlib.new(algorithm)
        try:
            with open(filepath, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_func.update(chunk)
            return hash_func.hexdigest()
        except Exception as e:
            self.log(f"Error calculating hash for {filepath}: {e}", 'ERROR')
            return ""
    
    def validate_file_path(self, filepath: str) -> bool:
        """Validate that file path exists and is readable."""
        try:
            path = Path(filepath)
            if not path.exists():
                self.log(f"File does not exist: {filepath}", 'ERROR')
                return False
            if not path.is_file():
                self.log(f"Path is not a file: {filepath}", 'ERROR')
                return False
            if not os.access(filepath, os.R_OK):
                self.log(f"File is not readable: {filepath}", 'ERROR')
                return False
            return True
        except Exception as e:
            self.log(f"Error validating file path {filepath}: {e}", 'ERROR')
            return False
    
    def upload_http(self, url: str, filepath: str, headers: Optional[Dict[str, str]] = None) -> bool:
        """Upload file via HTTP/HTTPS POST request."""
        if not self.validate_file_path(filepath):
            return False
        
        try:
            self.log(f"Starting HTTP upload of {filepath} to {url}")
            
            # Prepare file data
            with open(filepath, 'rb') as f:
                file_data = f.read()
            
            # Create request
            req = urllib.request.Request(url, data=file_data, method='POST')
            
            # Add headers
            if headers:
                for key, value in headers.items():
                    req.add_header(key, value)
            
            # Add content type
            req.add_header('Content-Type', 'application/octet-stream')
            req.add_header('Content-Length', str(len(file_data)))
            
            # Send request
            with urllib.request.urlopen(req) as response:
                if response.status == 200:
                    self.log(f"Successfully uploaded {filepath}")
                    return True
                else:
                    self.log(f"Upload failed with status: {response.status}", 'ERROR')
                    return False
                    
        except Exception as e:
            self.log(f"HTTP upload failed: {e}", 'ERROR')
            return False
    
    def upload_ftp(self, host: str, filepath: str, username: str = 'anonymous', 
                   password: str = '', remote_path: str = '', port: int = 21) -> bool:
        """Upload file via FTP."""
        if not self.validate_file_path(filepath):
            return False
        
        try:
            self.log(f"Starting FTP upload of {filepath} to {host}")
            
            # Connect to FTP server
            ftp = FTP()
            ftp.connect(host, port)
            ftp.login(username, password)
            
            # Change to remote directory if specified
            if remote_path:
                ftp.cwd(remote_path)
            
            # Upload file
            filename = os.path.basename(filepath)
            with open(filepath, 'rb') as f:
                ftp.storbinary(f'STOR {filename}', f)
            
            ftp.quit()
            self.log(f"Successfully uploaded {filepath} via FTP")
            return True
            
        except Exception as e:
            self.log(f"FTP upload failed: {e}", 'ERROR')
            return False
    
    def download_http(self, url: str, output_path: str = './') -> bool:
        """Download file via HTTP/HTTPS."""
        try:
            self.log(f"Starting HTTP download from {url}")
            
            # Create output directory if it doesn't exist
            os.makedirs(output_path, exist_ok=True)
            
            # Extract filename from URL
            filename = os.path.basename(urllib.parse.urlparse(url).path)
            if not filename:
                filename = 'downloaded_file'
            
            output_file = os.path.join(output_path, filename)
            
            # Download file
            urllib.request.urlretrieve(url, output_file)
            
            self.log(f"Successfully downloaded to {output_file}")
            return True
            
        except Exception as e:
            self.log(f"HTTP download failed: {e}", 'ERROR')
            return False
    
    def create_transfer_manifest(self, files: list, output_path: str) -> bool:
        """Create a manifest file with file information and checksums."""
        try:
            manifest = {
                'created': datetime.now().isoformat(),
                'files': []
            }
            
            for filepath in files:
                if self.validate_file_path(filepath):
                    file_info = {
                        'path': filepath,
                        'name': os.path.basename(filepath),
                        'size': os.path.getsize(filepath),
                        'sha256': self.calculate_file_hash(filepath, 'sha256'),
                        'modified': datetime.fromtimestamp(os.path.getmtime(filepath)).isoformat()
                    }
                    manifest['files'].append(file_info)
            
            # Write manifest
            with open(output_path, 'w') as f:
                json.dump(manifest, f, indent=2)
            
            self.log(f"Created transfer manifest: {output_path}")
            return True
            
        except Exception as e:
            self.log(f"Failed to create manifest: {e}", 'ERROR')
            return False
    
    def verify_transfer_integrity(self, filepath: str, expected_hash: str, algorithm: str = 'sha256') -> bool:
        """Verify file integrity using hash comparison."""
        if not self.validate_file_path(filepath):
            return False
        
        actual_hash = self.calculate_file_hash(filepath, algorithm)
        if actual_hash.lower() == expected_hash.lower():
            self.log(f"File integrity verified: {filepath}")
            return True
        else:
            self.log(f"File integrity check failed for {filepath}", 'ERROR')
            self.log(f"Expected: {expected_hash}", 'ERROR')
            self.log(f"Actual: {actual_hash}", 'ERROR')
            return False


class SecureFileServer:
    """Simple HTTP server for secure file sharing."""
    
    def __init__(self, directory: str, port: int = 8080, verbose: bool = False):
        self.directory = os.path.abspath(directory)
        self.port = port
        self.verbose = verbose
    
    def start_server(self) -> None:
        """Start the file server."""
        try:
            os.chdir(self.directory)
            handler = http.server.SimpleHTTPRequestHandler
            
            with socketserver.TCPServer(("", self.port), handler) as httpd:
                print(f"Serving files from {self.directory} on port {self.port}")
                print(f"Access via: http://localhost:{self.port}")
                print("Press Ctrl+C to stop the server")
                httpd.serve_forever()
                
        except KeyboardInterrupt:
            print("\nServer stopped by user")
        except Exception as e:
            print(f"Server error: {e}")


def main():
    """Main function to handle command-line arguments and execute operations."""
    parser = argparse.ArgumentParser(
        description='Secure Data Transfer Utility for legitimate file operations',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Upload file via HTTP
  %(prog)s upload --method http --url http://example.com/upload --file document.txt
  
  # Upload file via FTP
  %(prog)s upload --method ftp --host ftp.example.com --user myuser --file backup.zip
  
  # Download file
  %(prog)s download --url http://example.com/file.zip --output ./downloads/
  
  # Start file server
  %(prog)s serve --port 8080 --directory ./shared_files
  
  # Create file manifest
  %(prog)s manifest --files file1.txt file2.pdf --output manifest.json
        """
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Upload command
    upload_parser = subparsers.add_parser('upload', help='Upload files')
    upload_parser.add_argument('--method', choices=['http', 'https', 'ftp'], 
                              required=True, help='Transfer method')
    upload_parser.add_argument('--file', required=True, help='File to upload')
    upload_parser.add_argument('--url', help='HTTP/HTTPS URL for upload')
    upload_parser.add_argument('--host', help='FTP host')
    upload_parser.add_argument('--user', default='anonymous', help='FTP username')
    upload_parser.add_argument('--password', default='', help='FTP password')
    upload_parser.add_argument('--port', type=int, default=21, help='FTP port')
    upload_parser.add_argument('--remote-path', default='', help='Remote directory path')
    
    # Download command
    download_parser = subparsers.add_parser('download', help='Download files')
    download_parser.add_argument('--url', required=True, help='URL to download from')
    download_parser.add_argument('--output', default='./', help='Output directory')
    
    # Serve command
    serve_parser = subparsers.add_parser('serve', help='Start file server')
    serve_parser.add_argument('--port', type=int, default=8080, help='Server port')
    serve_parser.add_argument('--directory', default='./', help='Directory to serve')
    
    # Manifest command
    manifest_parser = subparsers.add_parser('manifest', help='Create file manifest')
    manifest_parser.add_argument('--files', nargs='+', required=True, help='Files to include')
    manifest_parser.add_argument('--output', required=True, help='Output manifest file')
    
    # Verify command
    verify_parser = subparsers.add_parser('verify', help='Verify file integrity')
    verify_parser.add_argument('--file', required=True, help='File to verify')
    verify_parser.add_argument('--hash', required=True, help='Expected hash')
    verify_parser.add_argument('--algorithm', default='sha256', help='Hash algorithm')
    
    # Global options
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return 1
    
    # Initialize transfer utility
    transfer = SecureDataTransfer(verbose=args.verbose)
    
    try:
        if args.command == 'upload':
            if args.method in ['http', 'https']:
                if not args.url:
                    print("Error: --url is required for HTTP/HTTPS uploads")
                    return 1
                success = transfer.upload_http(args.url, args.file)
            elif args.method == 'ftp':
                if not args.host:
                    print("Error: --host is required for FTP uploads")
                    return 1
                success = transfer.upload_ftp(
                    args.host, args.file, args.user, args.password, 
                    args.remote_path, args.port
                )
            else:
                print(f"Error: Unsupported method {args.method}")
                return 1
            
            return 0 if success else 1
        
        elif args.command == 'download':
            success = transfer.download_http(args.url, args.output)
            return 0 if success else 1
        
        elif args.command == 'serve':
            server = SecureFileServer(args.directory, args.port, args.verbose)
            server.start_server()
            return 0
        
        elif args.command == 'manifest':
            success = transfer.create_transfer_manifest(args.files, args.output)
            return 0 if success else 1
        
        elif args.command == 'verify':
            success = transfer.verify_transfer_integrity(args.file, args.hash, args.algorithm)
            return 0 if success else 1
    
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        return 1
    except Exception as e:
        print(f"Error: {e}")
        return 1


if __name__ == '__main__':
    sys.exit(main())
