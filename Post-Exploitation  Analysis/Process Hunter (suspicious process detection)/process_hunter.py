#!/usr/bin/env python3
"""
Process Hunter - Suspicious Process Detection Tool

This script monitors running processes and identifies potentially suspicious activity
based on various criteria such as unusual process names, high resource usage,
suspicious network connections, and known malware indicators.

Usage:
    python process_hunter.py --scan-all
    python process_hunter.py --monitor --interval 30
    python process_hunter.py --pid 1234 --detailed
    python process_hunter.py --export results.json

Author: Security Analyst
License: MIT
Version: 1.0.0
"""

import argparse
import json
import logging
import os
import platform
import psutil
import re
import sys
import time
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple


class ProcessHunter:
    """
    Main class for detecting suspicious processes and monitoring system activity.
    """
    
    def __init__(self, log_level: str = "INFO"):
        """
        Initialize the Process Hunter with logging configuration.
        
        Args:
            log_level (str): Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        """
        self.setup_logging(log_level)
        self.logger = logging.getLogger(__name__)
        
        # Suspicious process indicators
        self.suspicious_names = {
            # Common malware names
            'svchost.exe', 'lsass.exe', 'winlogon.exe', 'csrss.exe',
            # Potential malware (when in wrong locations)
            'cmd.exe', 'powershell.exe', 'wscript.exe', 'cscript.exe',
            # Crypto miners
            'xmrig', 'cpuminer', 'minerd', 'cgminer',
            # Remote access tools
            'teamviewer', 'anydesk', 'vnc', 'rdp',
            # Suspicious extensions
            '.tmp', '.exe', '.scr', '.bat', '.vbs', '.js'
        }
        
        # Legitimate system directories (Windows)
        self.system_dirs = {
            'C:\\Windows\\System32',
            'C:\\Windows\\SysWOW64',
            'C:\\Windows',
            'C:\\Program Files',
            'C:\\Program Files (x86)'
        }
        
        # High CPU/Memory thresholds
        self.cpu_threshold = 80.0  # Percentage
        self.memory_threshold = 80.0  # Percentage
        
        # Results storage
        self.scan_results = []
        self.alerts = []
    
    def setup_logging(self, log_level: str):
        """
        Configure logging for the application.
        
        Args:
            log_level (str): Logging level
        """
        log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        logging.basicConfig(
            level=getattr(logging, log_level.upper()),
            format=log_format,
            handlers=[
                logging.StreamHandler(sys.stdout),
                logging.FileHandler('process_hunter.log')
            ]
        )
    
    def is_suspicious_name(self, process_name: str, exe_path: str) -> Tuple[bool, str]:
        """
        Check if a process name is suspicious based on various criteria.
        
        Args:
            process_name (str): Name of the process
            exe_path (str): Full path to the executable
            
        Returns:
            Tuple[bool, str]: (is_suspicious, reason)
        """
        process_name_lower = process_name.lower()
        
        # Check for suspicious extensions in process names
        for ext in ['.tmp', '.scr', '.bat', '.vbs', '.js']:
            if process_name_lower.endswith(ext):
                return True, f"Suspicious file extension: {ext}"
        
        # Check for crypto mining software
        mining_keywords = ['miner', 'mining', 'xmr', 'btc', 'eth', 'crypto']
        for keyword in mining_keywords:
            if keyword in process_name_lower:
                return True, f"Potential crypto mining software: {keyword}"
        
        # Check for processes with random names (common malware technique)
        if len(process_name) > 8 and re.match(r'^[a-zA-Z0-9]{8,}\.exe$', process_name):
            if not any(char in process_name_lower for char in ['microsoft', 'google', 'adobe']):
                return True, "Potentially random process name"
        
        # Check for system processes running from non-system locations
        if platform.system() == "Windows":
            system_processes = ['svchost.exe', 'lsass.exe', 'winlogon.exe', 'csrss.exe']
            if process_name_lower in system_processes:
                if not any(sys_dir.lower() in exe_path.lower() for sys_dir in self.system_dirs):
                    return True, f"System process in non-system location: {exe_path}"
        
        return False, ""
    
    def check_resource_usage(self, process: psutil.Process) -> Tuple[bool, str]:
        """
        Check if a process is using excessive system resources.
        
        Args:
            process (psutil.Process): Process object to check
            
        Returns:
            Tuple[bool, str]: (is_suspicious, reason)
        """
        try:
            cpu_percent = process.cpu_percent(interval=1)
            memory_info = process.memory_info()
            memory_percent = process.memory_percent()
            
            if cpu_percent > self.cpu_threshold:
                return True, f"High CPU usage: {cpu_percent:.1f}%"
            
            if memory_percent > self.memory_threshold:
                return True, f"High memory usage: {memory_percent:.1f}%"
            
            # Check for excessive file handles (potential resource exhaustion)
            try:
                num_handles = process.num_handles() if platform.system() == "Windows" else len(process.open_files())
                if num_handles > 1000:
                    return True, f"Excessive file handles: {num_handles}"
            except (psutil.AccessDenied, psutil.NoSuchProcess):
                pass
                
        except (psutil.AccessDenied, psutil.NoSuchProcess, psutil.ZombieProcess):
            pass
        
        return False, ""
    
    def check_network_connections(self, process: psutil.Process) -> Tuple[bool, str]:
        """
        Check for suspicious network connections.
        
        Args:
            process (psutil.Process): Process object to check
            
        Returns:
            Tuple[bool, str]: (is_suspicious, reason)
        """
        try:
            connections = process.connections(kind='inet')
            
            # Check for excessive connections
            if len(connections) > 50:
                return True, f"Excessive network connections: {len(connections)}"
            
            # Check for connections to suspicious ports
            suspicious_ports = {6667, 6668, 6669, 1337, 31337, 4444, 5555}
            for conn in connections:
                if conn.status == psutil.CONN_ESTABLISHED:
                    if conn.laddr.port in suspicious_ports or conn.raddr.port in suspicious_ports:
                        return True, f"Connection to suspicious port: {conn.raddr.port}"
            
        except (psutil.AccessDenied, psutil.NoSuchProcess):
            pass
        
        return False, ""
    
    def analyze_process(self, process: psutil.Process) -> Dict:
        """
        Perform comprehensive analysis of a single process.
        
        Args:
            process (psutil.Process): Process object to analyze
            
        Returns:
            Dict: Analysis results
        """
        try:
            # Basic process information
            info = {
                'pid': process.pid,
                'name': process.name(),
                'exe': process.exe(),
                'cmdline': ' '.join(process.cmdline()),
                'create_time': datetime.fromtimestamp(process.create_time()).isoformat(),
                'status': process.status(),
                'cpu_percent': 0.0,
                'memory_percent': 0.0,
                'suspicious': False,
                'alerts': []
            }
            
            # Check for suspicious name
            is_susp_name, name_reason = self.is_suspicious_name(info['name'], info['exe'])
            if is_susp_name:
                info['suspicious'] = True
                info['alerts'].append(f"Suspicious name: {name_reason}")
            
            # Check resource usage
            is_susp_resource, resource_reason = self.check_resource_usage(process)
            if is_susp_resource:
                info['suspicious'] = True
                info['alerts'].append(f"Resource usage: {resource_reason}")
            
            # Check network connections
            is_susp_network, network_reason = self.check_network_connections(process)
            if is_susp_network:
                info['suspicious'] = True
                info['alerts'].append(f"Network activity: {network_reason}")
            
            # Get additional metrics
            try:
                info['cpu_percent'] = process.cpu_percent()
                info['memory_percent'] = process.memory_percent()
                info['num_threads'] = process.num_threads()
                info['username'] = process.username()
            except (psutil.AccessDenied, psutil.NoSuchProcess):
                pass
            
            return info
            
        except (psutil.NoSuchProcess, psutil.ZombieProcess):
            return None
    
    def scan_all_processes(self) -> List[Dict]:
        """
        Scan all running processes for suspicious activity.
        
        Returns:
            List[Dict]: List of process analysis results
        """
        self.logger.info("Starting comprehensive process scan...")
        results = []
        suspicious_count = 0
        
        for process in psutil.process_iter(['pid', 'name']):
            try:
                analysis = self.analyze_process(process)
                if analysis:
                    results.append(analysis)
                    if analysis['suspicious']:
                        suspicious_count += 1
                        self.logger.warning(f"Suspicious process detected: {analysis['name']} (PID: {analysis['pid']})")
                        
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                continue
        
        self.logger.info(f"Scan complete. Found {suspicious_count} suspicious processes out of {len(results)} total.")
        self.scan_results = results
        return results
    
    def monitor_processes(self, interval: int = 30, duration: Optional[int] = None):
        """
        Continuously monitor processes for suspicious activity.
        
        Args:
            interval (int): Monitoring interval in seconds
            duration (Optional[int]): Total monitoring duration in seconds (None for infinite)
        """
        self.logger.info(f"Starting process monitoring (interval: {interval}s, duration: {duration}s)")
        
        start_time = time.time()
        previous_pids = set()
        
        try:
            while True:
                current_time = time.time()
                
                # Check if monitoring duration exceeded
                if duration and (current_time - start_time) > duration:
                    break
                
                # Get current process list
                current_pids = set()
                new_processes = []
                
                for process in psutil.process_iter(['pid', 'name']):
                    try:
                        pid = process.info['pid']
                        current_pids.add(pid)
                        
                        # Check for new processes
                        if pid not in previous_pids:
                            analysis = self.analyze_process(process)
                            if analysis and analysis['suspicious']:
                                new_processes.append(analysis)
                                self.logger.warning(f"New suspicious process: {analysis['name']} (PID: {pid})")
                                
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
                
                # Update previous PIDs
                previous_pids = current_pids
                
                # Sleep for the specified interval
                time.sleep(interval)
                
        except KeyboardInterrupt:
            self.logger.info("Monitoring stopped by user.")
    
    def analyze_specific_process(self, pid: int) -> Optional[Dict]:
        """
        Analyze a specific process by PID.
        
        Args:
            pid (int): Process ID to analyze
            
        Returns:
            Optional[Dict]: Analysis results or None if process not found
        """
        try:
            process = psutil.Process(pid)
            analysis = self.analyze_process(process)
            
            if analysis:
                self.logger.info(f"Analysis complete for PID {pid}")
                if analysis['suspicious']:
                    self.logger.warning(f"Process {pid} flagged as suspicious!")
                else:
                    self.logger.info(f"Process {pid} appears normal.")
            
            return analysis
            
        except psutil.NoSuchProcess:
            self.logger.error(f"Process with PID {pid} not found.")
            return None
    
    def export_results(self, filename: str, format_type: str = "json"):
        """
        Export scan results to a file.
        
        Args:
            filename (str): Output filename
            format_type (str): Export format ('json' or 'csv')
        """
        if not self.scan_results:
            self.logger.warning("No scan results to export. Run a scan first.")
            return
        
        try:
            if format_type.lower() == "json":
                with open(filename, 'w') as f:
                    json.dump({
                        'scan_timestamp': datetime.now().isoformat(),
                        'total_processes': len(self.scan_results),
                        'suspicious_processes': len([p for p in self.scan_results if p['suspicious']]),
                        'results': self.scan_results
                    }, f, indent=2)
                    
            elif format_type.lower() == "csv":
                import csv
                with open(filename, 'w', newline='') as f:
                    writer = csv.writer(f)
                    writer.writerow(['PID', 'Name', 'Executable', 'Suspicious', 'Alerts', 'CPU%', 'Memory%'])
                    
                    for result in self.scan_results:
                        writer.writerow([
                            result['pid'],
                            result['name'],
                            result['exe'],
                            result['suspicious'],
                            '; '.join(result['alerts']),
                            result['cpu_percent'],
                            result['memory_percent']
                        ])
            
            self.logger.info(f"Results exported to {filename}")
            
        except Exception as e:
            self.logger.error(f"Failed to export results: {str(e)}")


def main():
    """
    Main function to handle command-line arguments and execute the appropriate functionality.
    """
    parser = argparse.ArgumentParser(
        description="Process Hunter - Suspicious Process Detection Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python process_hunter.py --scan-all
    python process_hunter.py --monitor --interval 30 --duration 3600
    python process_hunter.py --pid 1234 --detailed
    python process_hunter.py --scan-all --export results.json
        """
    )
    
    # Main operation modes
    parser.add_argument('--scan-all', action='store_true',
                        help='Scan all running processes for suspicious activity')
    parser.add_argument('--monitor', action='store_true',
                        help='Continuously monitor for suspicious processes')
    parser.add_argument('--pid', type=int, metavar='PID',
                        help='Analyze a specific process by PID')
    
    # Monitoring options
    parser.add_argument('--interval', type=int, default=30, metavar='SECONDS',
                        help='Monitoring interval in seconds (default: 30)')
    parser.add_argument('--duration', type=int, metavar='SECONDS',
                        help='Total monitoring duration in seconds (default: infinite)')
    
    # Output options
    parser.add_argument('--export', type=str, metavar='FILENAME',
                        help='Export results to file (JSON or CSV based on extension)')
    parser.add_argument('--detailed', action='store_true',
                        help='Show detailed analysis output')
    
    # General options
    parser.add_argument('--log-level', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                        default='INFO', help='Set logging level (default: INFO)')
    
    args = parser.parse_args()
    
    # Initialize Process Hunter
    hunter = ProcessHunter(log_level=args.log_level)
    
    try:
        # Execute based on command-line arguments
        if args.scan_all:
            results = hunter.scan_all_processes()
            
            # Display results
            suspicious_results = [r for r in results if r['suspicious']]
            if suspicious_results:
                print(f"\n{'='*60}")
                print(f"SUSPICIOUS PROCESSES DETECTED: {len(suspicious_results)}")
                print(f"{'='*60}")
                
                for result in suspicious_results:
                    print(f"\nPID: {result['pid']}")
                    print(f"Name: {result['name']}")
                    print(f"Executable: {result['exe']}")
                    print(f"Alerts: {'; '.join(result['alerts'])}")
                    if args.detailed:
                        print(f"Command Line: {result['cmdline']}")
                        print(f"CPU: {result['cpu_percent']:.1f}%")
                        print(f"Memory: {result['memory_percent']:.1f}%")
            else:
                print("\nNo suspicious processes detected.")
            
        elif args.monitor:
            hunter.monitor_processes(interval=args.interval, duration=args.duration)
            
        elif args.pid:
            result = hunter.analyze_specific_process(args.pid)
            if result:
                print(f"\nProcess Analysis for PID {args.pid}:")
                print(f"Name: {result['name']}")
                print(f"Executable: {result['exe']}")
                print(f"Suspicious: {'YES' if result['suspicious'] else 'NO'}")
                if result['alerts']:
                    print(f"Alerts: {'; '.join(result['alerts'])}")
                if args.detailed:
                    print(f"Command Line: {result['cmdline']}")
                    print(f"Status: {result['status']}")
                    print(f"CPU: {result['cpu_percent']:.1f}%")
                    print(f"Memory: {result['memory_percent']:.1f}%")
        else:
            parser.print_help()
            return
        
        # Export results if requested
        if args.export and hunter.scan_results:
            file_ext = Path(args.export).suffix.lower()
            format_type = "csv" if file_ext == ".csv" else "json"
            hunter.export_results(args.export, format_type)
            
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
    except Exception as e:
        hunter.logger.error(f"An error occurred: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()
