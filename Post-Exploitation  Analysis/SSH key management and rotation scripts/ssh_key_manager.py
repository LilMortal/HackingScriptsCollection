#!/usr/bin/env python3
"""
SSH Key Management and Rotation Script

This script provides functionality to manage SSH keys including:
- Generate new SSH key pairs
- Rotate existing SSH keys
- Backup old keys
- Deploy new keys to remote servers
- Validate key configurations

Usage Examples:
    python ssh_key_manager.py generate --key-name mykey --key-type rsa
    python ssh_key_manager.py rotate --key-name mykey --servers server1,server2
    python ssh_key_manager.py validate --key-path ~/.ssh/id_rsa.pub
    python ssh_key_manager.py backup --ssh-dir ~/.ssh --backup-dir ~/ssh_backup

Author: System Administrator
License: MIT
"""

import argparse
import os
import sys
import subprocess
import shutil
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional, Tuple
import re


class SSHKeyManager:
    """Main class for SSH key management operations"""
    
    def __init__(self, ssh_dir: str = None, verbose: bool = False):
        """
        Initialize SSH Key Manager
        
        Args:
            ssh_dir: SSH directory path (default: ~/.ssh)
            verbose: Enable verbose logging
        """
        self.ssh_dir = Path(ssh_dir) if ssh_dir else Path.home() / '.ssh'
        self.backup_dir = self.ssh_dir / 'backups'
        
        # Setup logging
        log_level = logging.DEBUG if verbose else logging.INFO
        logging.basicConfig(
            level=log_level,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
        
        # Ensure SSH directory exists
        self.ssh_dir.mkdir(mode=0o700, exist_ok=True)
        
    def generate_key_pair(self, key_name: str, key_type: str = 'rsa', 
                         key_size: int = 4096, comment: str = None) -> bool:
        """
        Generate a new SSH key pair
        
        Args:
            key_name: Name for the key files
            key_type: Type of key (rsa, ed25519, ecdsa)
            key_size: Key size in bits (for RSA keys)
            comment: Optional comment for the key
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            private_key_path = self.ssh_dir / key_name
            public_key_path = self.ssh_dir / f"{key_name}.pub"
            
            # Check if key already exists
            if private_key_path.exists():
                self.logger.warning(f"Key {key_name} already exists")
                return False
            
            # Build ssh-keygen command
            cmd = ['ssh-keygen', '-t', key_type, '-f', str(private_key_path)]
            
            if key_type == 'rsa':
                cmd.extend(['-b', str(key_size)])
            
            if comment:
                cmd.extend(['-C', comment])
            else:
                cmd.extend(['-C', f"{os.getenv('USER', 'user')}@{os.uname().nodename}"])
            
            # Generate without passphrase for automation (can be modified)
            cmd.extend(['-N', ''])
            
            self.logger.info(f"Generating {key_type} key pair: {key_name}")
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                # Set proper permissions
                private_key_path.chmod(0o600)
                public_key_path.chmod(0o644)
                
                self.logger.info(f"Successfully generated key pair: {key_name}")
                self.logger.info(f"Private key: {private_key_path}")
                self.logger.info(f"Public key: {public_key_path}")
                return True
            else:
                self.logger.error(f"Failed to generate key: {result.stderr}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error generating key pair: {str(e)}")
            return False
    
    def backup_keys(self, backup_location: str = None) -> bool:
        """
        Backup SSH keys to specified location
        
        Args:
            backup_location: Custom backup directory path
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            if backup_location:
                backup_path = Path(backup_location)
            else:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_path = self.backup_dir / f"backup_{timestamp}"
            
            backup_path.mkdir(parents=True, exist_ok=True)
            
            # Find all SSH key files
            key_files = []
            for file_path in self.ssh_dir.glob('*'):
                if file_path.is_file() and not file_path.name.startswith('.'):
                    # Check if it's a key file
                    if (file_path.suffix == '.pub' or 
                        self._is_private_key(file_path)):
                        key_files.append(file_path)
            
            if not key_files:
                self.logger.warning("No SSH keys found to backup")
                return False
            
            # Copy key files to backup location
            for key_file in key_files:
                dest_file = backup_path / key_file.name
                shutil.copy2(key_file, dest_file)
                dest_file.chmod(key_file.stat().st_mode)
                self.logger.debug(f"Backed up: {key_file.name}")
            
            self.logger.info(f"Successfully backed up {len(key_files)} key files to {backup_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error backing up keys: {str(e)}")
            return False
    
    def rotate_key(self, key_name: str, servers: List[str] = None, 
                   new_key_type: str = 'rsa') -> bool:
        """
        Rotate an SSH key (backup old, generate new, optionally deploy)
        
        Args:
            key_name: Name of the key to rotate
            servers: List of servers to deploy new key to
            new_key_type: Type for the new key
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            private_key_path = self.ssh_dir / key_name
            public_key_path = self.ssh_dir / f"{key_name}.pub"
            
            # Check if key exists
            if not private_key_path.exists():
                self.logger.error(f"Key {key_name} does not exist")
                return False
            
            # Backup existing key
            self.logger.info(f"Backing up existing key: {key_name}")
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = f"{key_name}_backup_{timestamp}"
            
            backup_private = self.ssh_dir / backup_name
            backup_public = self.ssh_dir / f"{backup_name}.pub"
            
            shutil.copy2(private_key_path, backup_private)
            if public_key_path.exists():
                shutil.copy2(public_key_path, backup_public)
            
            # Remove old key
            private_key_path.unlink()
            if public_key_path.exists():
                public_key_path.unlink()
            
            # Generate new key
            self.logger.info(f"Generating new key: {key_name}")
            if not self.generate_key_pair(key_name, new_key_type):
                # Restore backup if generation failed
                shutil.copy2(backup_private, private_key_path)
                if backup_public.exists():
                    shutil.copy2(backup_public, public_key_path)
                return False
            
            # Deploy to servers if specified
            if servers:
                self.logger.info("Deploying new key to servers...")
                for server in servers:
                    if self.deploy_key_to_server(key_name, server):
                        self.logger.info(f"Successfully deployed to {server}")
                    else:
                        self.logger.warning(f"Failed to deploy to {server}")
            
            self.logger.info(f"Successfully rotated key: {key_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error rotating key: {str(e)}")
            return False
    
    def deploy_key_to_server(self, key_name: str, server: str, 
                           username: str = None) -> bool:
        """
        Deploy public key to a remote server
        
        Args:
            key_name: Name of the key to deploy
            server: Server hostname or IP
            username: Username for the server (optional)
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            public_key_path = self.ssh_dir / f"{key_name}.pub"
            
            if not public_key_path.exists():
                self.logger.error(f"Public key not found: {public_key_path}")
                return False
            
            # Build ssh-copy-id command
            target = f"{username}@{server}" if username else server
            cmd = ['ssh-copy-id', '-i', str(public_key_path), target]
            
            self.logger.info(f"Deploying key to {target}")
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                self.logger.info(f"Successfully deployed key to {target}")
                return True
            else:
                self.logger.error(f"Failed to deploy key to {target}: {result.stderr}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error deploying key to server: {str(e)}")
            return False
    
    def validate_key(self, key_path: str) -> Dict[str, any]:
        """
        Validate an SSH key and return information about it
        
        Args:
            key_path: Path to the key file
            
        Returns:
            dict: Key information and validation results
        """
        try:
            key_file = Path(key_path)
            if not key_file.exists():
                return {'valid': False, 'error': 'Key file does not exist'}
            
            # Check if it's a public key
            if key_path.endswith('.pub'):
                cmd = ['ssh-keygen', '-l', '-f', str(key_file)]
            else:
                cmd = ['ssh-keygen', '-l', '-f', str(key_file)]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                # Parse output
                output_parts = result.stdout.strip().split()
                key_info = {
                    'valid': True,
                    'bits': output_parts[0],
                    'fingerprint': output_parts[1],
                    'comment': ' '.join(output_parts[2:]) if len(output_parts) > 2 else '',
                    'file_permissions': oct(key_file.stat().st_mode)[-3:],
                    'file_size': key_file.stat().st_size
                }
                
                # Check permissions
                if key_path.endswith('.pub'):
                    expected_perms = '644'
                else:
                    expected_perms = '600'
                
                if key_info['file_permissions'] != expected_perms:
                    key_info['permission_warning'] = f"Expected {expected_perms}, got {key_info['file_permissions']}"
                
                return key_info
            else:
                return {'valid': False, 'error': result.stderr.strip()}
                
        except Exception as e:
            return {'valid': False, 'error': str(e)}
    
    def list_keys(self) -> List[Dict[str, any]]:
        """
        List all SSH keys in the SSH directory
        
        Returns:
            list: List of key information dictionaries
        """
        keys = []
        
        try:
            for file_path in self.ssh_dir.glob('*'):
                if file_path.is_file() and not file_path.name.startswith('.'):
                    if (file_path.suffix == '.pub' or 
                        self._is_private_key(file_path)):
                        
                        key_info = self.validate_key(str(file_path))
                        key_info['name'] = file_path.name
                        key_info['path'] = str(file_path)
                        key_info['modified'] = datetime.fromtimestamp(
                            file_path.stat().st_mtime
                        ).strftime('%Y-%m-%d %H:%M:%S')
                        
                        keys.append(key_info)
            
            return sorted(keys, key=lambda x: x['name'])
            
        except Exception as e:
            self.logger.error(f"Error listing keys: {str(e)}")
            return []
    
    def _is_private_key(self, file_path: Path) -> bool:
        """
        Check if a file is likely a private SSH key
        
        Args:
            file_path: Path to the file to check
            
        Returns:
            bool: True if likely a private key, False otherwise
        """
        try:
            with open(file_path, 'r') as f:
                first_line = f.readline().strip()
                return (first_line.startswith('-----BEGIN') and 
                       'PRIVATE KEY' in first_line)
        except Exception:
            return False


def main():
    """Main function to handle command line arguments and execute operations"""
    
    parser = argparse.ArgumentParser(
        description='SSH Key Management and Rotation Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Generate a new RSA key:
    %(prog)s generate --key-name mykey --key-type rsa
    
  Rotate an existing key:
    %(prog)s rotate --key-name mykey --servers server1.example.com,server2.example.com
    
  Backup all keys:
    %(prog)s backup --backup-dir ~/ssh_backup
    
  Validate a key:
    %(prog)s validate --key-path ~/.ssh/id_rsa.pub
    
  List all keys:
    %(prog)s list
        """
    )
    
    parser.add_argument('--ssh-dir', default=None,
                       help='SSH directory path (default: ~/.ssh)')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Enable verbose output')
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Generate command
    gen_parser = subparsers.add_parser('generate', help='Generate new SSH key pair')
    gen_parser.add_argument('--key-name', required=True,
                           help='Name for the new key')
    gen_parser.add_argument('--key-type', default='rsa', 
                           choices=['rsa', 'ed25519', 'ecdsa'],
                           help='Type of key to generate')
    gen_parser.add_argument('--key-size', type=int, default=4096,
                           help='Key size in bits (for RSA keys)')
    gen_parser.add_argument('--comment',
                           help='Comment for the key')
    
    # Rotate command
    rot_parser = subparsers.add_parser('rotate', help='Rotate existing SSH key')
    rot_parser.add_argument('--key-name', required=True,
                           help='Name of the key to rotate')
    rot_parser.add_argument('--servers',
                           help='Comma-separated list of servers to deploy to')
    rot_parser.add_argument('--new-key-type', default='rsa',
                           choices=['rsa', 'ed25519', 'ecdsa'],
                           help='Type for the new key')
    
    # Backup command
    backup_parser = subparsers.add_parser('backup', help='Backup SSH keys')
    backup_parser.add_argument('--backup-dir',
                              help='Custom backup directory')
    
    # Validate command
    val_parser = subparsers.add_parser('validate', help='Validate SSH key')
    val_parser.add_argument('--key-path', required=True,
                           help='Path to key file to validate')
    
    # List command
    list_parser = subparsers.add_parser('list', help='List all SSH keys')
    
    # Deploy command
    deploy_parser = subparsers.add_parser('deploy', help='Deploy key to server')
    deploy_parser.add_argument('--key-name', required=True,
                              help='Name of key to deploy')
    deploy_parser.add_argument('--server', required=True,
                              help='Server to deploy to')
    deploy_parser.add_argument('--username',
                              help='Username for the server')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return 1
    
    # Initialize SSH Key Manager
    manager = SSHKeyManager(ssh_dir=args.ssh_dir, verbose=args.verbose)
    
    try:
        if args.command == 'generate':
            success = manager.generate_key_pair(
                key_name=args.key_name,
                key_type=args.key_type,
                key_size=args.key_size,
                comment=args.comment
            )
            return 0 if success else 1
            
        elif args.command == 'rotate':
            servers = args.servers.split(',') if args.servers else None
            success = manager.rotate_key(
                key_name=args.key_name,
                servers=servers,
                new_key_type=args.new_key_type
            )
            return 0 if success else 1
            
        elif args.command == 'backup':
            success = manager.backup_keys(backup_location=args.backup_dir)
            return 0 if success else 1
            
        elif args.command == 'validate':
            result = manager.validate_key(args.key_path)
            if result['valid']:
                print(f"✓ Key is valid")
                print(f"  Bits: {result['bits']}")
                print(f"  Fingerprint: {result['fingerprint']}")
                print(f"  Comment: {result['comment']}")
                print(f"  Permissions: {result['file_permissions']}")
                if 'permission_warning' in result:
                    print(f"  ⚠ Permission Warning: {result['permission_warning']}")
            else:
                print(f"✗ Key validation failed: {result['error']}")
                return 1
            return 0
            
        elif args.command == 'list':
            keys = manager.list_keys()
            if keys:
                print(f"Found {len(keys)} SSH keys:")
                print("-" * 80)
                for key in keys:
                    status = "✓" if key['valid'] else "✗"
                    print(f"{status} {key['name']}")
                    if key['valid']:
                        print(f"    Fingerprint: {key['fingerprint']}")
                        print(f"    Modified: {key['modified']}")
                    else:
                        print(f"    Error: {key['error']}")
                    print()
            else:
                print("No SSH keys found")
            return 0
            
        elif args.command == 'deploy':
            success = manager.deploy_key_to_server(
                key_name=args.key_name,
                server=args.server,
                username=args.username
            )
            return 0 if success else 1
            
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        return 1
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
        return 1


if __name__ == '__main__':
    sys.exit(main())
