#!/usr/bin/env python3
"""
System Monitor Tool - Tracks legitimate system events for security awareness

This script monitors various system events including:
- File system changes (creation, modification, deletion)
- Network connections
- Process monitoring
- System resource usage

Usage:
    python system_monitor.py --monitor-files /path/to/watch --duration 300
    python system_monitor.py --monitor-network --log-file system_events.log
    python system_monitor.py --monitor-all --duration 600 --verbose

Author: Security Awareness Tool
License: MIT
"""

import argparse
import json
import logging
import os
import platform
import psutil
import signal
import socket
import sys
import threading
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Set

try:
    from watchdog.observers import Observer
    from watchdog.events import FileSystemEventHandler
    WATCHDOG_AVAILABLE = True
except ImportError:
    WATCHDOG_AVAILABLE = False


class SystemMonitor:
    """Main system monitoring class that coordinates all monitoring activities."""
    
    def __init__(self, log_file: Optional[str] = None, verbose: bool = False):
        """
        Initialize the system monitor.
        
        Args:
            log_file: Optional path to log file for persistent logging
            verbose: Enable verbose console output
        """
        self.running = False
        self.verbose = verbose
        self.start_time = datetime.now()
        
        # Setup logging
        self.setup_logging(log_file)
        
        # Initialize monitoring components
        self.file_monitor = FileSystemMonitor(self.logger) if WATCHDOG_AVAILABLE else None
        self.network_monitor = NetworkMonitor(self.logger)
        self.process_monitor = ProcessMonitor(self.logger)
        self.resource_monitor = ResourceMonitor(self.logger)
        
        # Signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
    
    def setup_logging(self, log_file: Optional[str]) -> None:
        """Configure logging for the system monitor."""
        self.logger = logging.getLogger('SystemMonitor')
        self.logger.setLevel(logging.INFO)
        
        # Create formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        if not self.verbose:
            console_handler.setLevel(logging.WARNING)
        self.logger.addHandler(console_handler)
        
        # File handler (if specified)
        if log_file:
            try:
                file_handler = logging.FileHandler(log_file)
                file_handler.setFormatter(formatter)
                self.logger.addHandler(file_handler)
                self.logger.info(f"Logging to file: {log_file}")
            except Exception as e:
                self.logger.error(f"Failed to setup file logging: {e}")
    
    def signal_handler(self, signum, frame):
        """Handle shutdown signals gracefully."""
        self.logger.info(f"Received signal {signum}, shutting down...")
        self.stop_monitoring()
        sys.exit(0)
    
    def start_monitoring(self, config: Dict) -> None:
        """
        Start monitoring based on configuration.
        
        Args:
            config: Dictionary containing monitoring configuration
        """
        self.running = True
        self.logger.info("Starting system monitoring...")
        self.logger.info(f"Platform: {platform.system()} {platform.release()}")
        
        threads = []
        
        # Start file system monitoring
        if config.get('monitor_files') and self.file_monitor:
            paths = config.get('watch_paths', [])
            if paths:
                for path in paths:
                    self.file_monitor.add_watch_path(path)
                thread = threading.Thread(target=self.file_monitor.start_monitoring)
                thread.daemon = True
                thread.start()
                threads.append(thread)
                self.logger.info(f"File monitoring started for paths: {paths}")
        
        # Start network monitoring
        if config.get('monitor_network'):
            thread = threading.Thread(target=self.network_monitor.start_monitoring)
            thread.daemon = True
            thread.start()
            threads.append(thread)
            self.logger.info("Network monitoring started")
        
        # Start process monitoring
        if config.get('monitor_processes'):
            thread = threading.Thread(target=self.process_monitor.start_monitoring)
            thread.daemon = True
            thread.start()
            threads.append(thread)
            self.logger.info("Process monitoring started")
        
        # Start resource monitoring
        if config.get('monitor_resources'):
            thread = threading.Thread(target=self.resource_monitor.start_monitoring)
            thread.daemon = True
            thread.start()
            threads.append(thread)
            self.logger.info("Resource monitoring started")
        
        # Main monitoring loop
        duration = config.get('duration', 0)
        if duration > 0:
            self.logger.info(f"Monitoring for {duration} seconds...")
            time.sleep(duration)
            self.stop_monitoring()
        else:
            self.logger.info("Monitoring indefinitely (Ctrl+C to stop)...")
            try:
                while self.running:
                    time.sleep(1)
            except KeyboardInterrupt:
                self.stop_monitoring()
    
    def stop_monitoring(self) -> None:
        """Stop all monitoring activities."""
        self.running = False
        self.logger.info("Stopping system monitoring...")
        
        if self.file_monitor:
            self.file_monitor.stop_monitoring()
        
        # Log summary
        runtime = datetime.now() - self.start_time
        self.logger.info(f"Monitoring session completed. Runtime: {runtime}")


class FileSystemMonitor:
    """Monitors file system events using watchdog library."""
    
    def __init__(self, logger):
        self.logger = logger
        self.observer = Observer() if WATCHDOG_AVAILABLE else None
        self.watch_paths = []
        self.event_handler = FileEventHandler(logger)
    
    def add_watch_path(self, path: str) -> None:
        """Add a path to monitor for file system events."""
        if not os.path.exists(path):
            self.logger.error(f"Watch path does not exist: {path}")
            return
        
        self.watch_paths.append(path)
        if self.observer:
            self.observer.schedule(self.event_handler, path, recursive=True)
    
    def start_monitoring(self) -> None:
        """Start file system monitoring."""
        if not self.observer:
            self.logger.error("Watchdog not available for file monitoring")
            return
        
        try:
            self.observer.start()
            while self.observer.is_alive():
                time.sleep(1)
        except Exception as e:
            self.logger.error(f"File monitoring error: {e}")
    
    def stop_monitoring(self) -> None:
        """Stop file system monitoring."""
        if self.observer and self.observer.is_alive():
            self.observer.stop()
            self.observer.join()


class FileEventHandler(FileSystemEventHandler):
    """Handles file system events."""
    
    def __init__(self, logger):
        self.logger = logger
        super().__init__()
    
    def on_created(self, event):
        if not event.is_directory:
            self.logger.info(f"FILE_CREATED: {event.src_path}")
    
    def on_modified(self, event):
        if not event.is_directory:
            self.logger.info(f"FILE_MODIFIED: {event.src_path}")
    
    def on_deleted(self, event):
        if not event.is_directory:
            self.logger.info(f"FILE_DELETED: {event.src_path}")
    
    def on_moved(self, event):
        if not event.is_directory:
            self.logger.info(f"FILE_MOVED: {event.src_path} -> {event.dest_path}")


class NetworkMonitor:
    """Monitors network connections and activity."""
    
    def __init__(self, logger):
        self.logger = logger
        self.known_connections = set()
        self.running = False
    
    def start_monitoring(self) -> None:
        """Start network monitoring."""
        self.running = True
        self.logger.info("Network monitoring started")
        
        while self.running:
            try:
                self.check_network_connections()
                time.sleep(5)  # Check every 5 seconds
            except Exception as e:
                self.logger.error(f"Network monitoring error: {e}")
                time.sleep(5)
    
    def check_network_connections(self) -> None:
        """Check for new network connections."""
        try:
            current_connections = set()
            
            for conn in psutil.net_connections(kind='inet'):
                if conn.status == psutil.CONN_ESTABLISHED:
                    conn_info = (
                        conn.laddr.ip if conn.laddr else 'N/A',
                        conn.laddr.port if conn.laddr else 0,
                        conn.raddr.ip if conn.raddr else 'N/A',
                        conn.raddr.port if conn.raddr else 0,
                        conn.pid
                    )
                    current_connections.add(conn_info)
            
            # Log new connections
            new_connections = current_connections - self.known_connections
            for conn in new_connections:
                local_addr, local_port, remote_addr, remote_port, pid = conn
                try:
                    process_name = psutil.Process(pid).name() if pid else 'Unknown'
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    process_name = 'Unknown'
                
                self.logger.info(
                    f"NEW_CONNECTION: {local_addr}:{local_port} -> "
                    f"{remote_addr}:{remote_port} (Process: {process_name}, PID: {pid})"
                )
            
            self.known_connections = current_connections
            
        except Exception as e:
            self.logger.error(f"Error checking network connections: {e}")


class ProcessMonitor:
    """Monitors system processes."""
    
    def __init__(self, logger):
        self.logger = logger
        self.known_processes = set()
        self.running = False
    
    def start_monitoring(self) -> None:
        """Start process monitoring."""
        self.running = True
        self.logger.info("Process monitoring started")
        
        # Initialize known processes
        self.update_known_processes()
        
        while self.running:
            try:
                self.check_process_changes()
                time.sleep(3)  # Check every 3 seconds
            except Exception as e:
                self.logger.error(f"Process monitoring error: {e}")
                time.sleep(3)
    
    def update_known_processes(self) -> None:
        """Update the set of known processes."""
        try:
            self.known_processes = {proc.pid for proc in psutil.process_iter(['pid'])}
        except Exception as e:
            self.logger.error(f"Error updating known processes: {e}")
    
    def check_process_changes(self) -> None:
        """Check for new or terminated processes."""
        try:
            current_processes = set()
            process_info = {}
            
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    pid = proc.info['pid']
                    current_processes.add(pid)
                    process_info[pid] = {
                        'name': proc.info['name'],
                        'cmdline': ' '.join(proc.info['cmdline']) if proc.info['cmdline'] else ''
                    }
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
            
            # Log new processes
            new_processes = current_processes - self.known_processes
            for pid in new_processes:
                if pid in process_info:
                    info = process_info[pid]
                    self.logger.info(
                        f"NEW_PROCESS: PID={pid}, Name={info['name']}, "
                        f"Command={info['cmdline'][:100]}..."
                    )
            
            # Log terminated processes
            terminated_processes = self.known_processes - current_processes
            for pid in terminated_processes:
                self.logger.info(f"PROCESS_TERMINATED: PID={pid}")
            
            self.known_processes = current_processes
            
        except Exception as e:
            self.logger.error(f"Error checking process changes: {e}")


class ResourceMonitor:
    """Monitors system resource usage."""
    
    def __init__(self, logger):
        self.logger = logger
        self.running = False
    
    def start_monitoring(self) -> None:
        """Start resource monitoring."""
        self.running = True
        self.logger.info("Resource monitoring started")
        
        while self.running:
            try:
                self.log_resource_usage()
                time.sleep(60)  # Log every minute
            except Exception as e:
                self.logger.error(f"Resource monitoring error: {e}")
                time.sleep(60)
    
    def log_resource_usage(self) -> None:
        """Log current system resource usage."""
        try:
            # CPU usage
            cpu_percent = psutil.cpu_percent(interval=1)
            
            # Memory usage
            memory = psutil.virtual_memory()
            memory_percent = memory.percent
            
            # Disk usage
            disk = psutil.disk_usage('/')
            disk_percent = (disk.used / disk.total) * 100
            
            # Network stats
            net_io = psutil.net_io_counters()
            
            self.logger.info(
                f"RESOURCE_USAGE: CPU={cpu_percent:.1f}%, "
                f"Memory={memory_percent:.1f}%, Disk={disk_percent:.1f}%, "
                f"Network_In={net_io.bytes_recv}, Network_Out={net_io.bytes_sent}"
            )
            
        except Exception as e:
            self.logger.error(f"Error logging resource usage: {e}")


def validate_arguments(args) -> Dict:
    """Validate and process command line arguments."""
    config = {
        'monitor_files': args.monitor_files or args.monitor_all,
        'monitor_network': args.monitor_network or args.monitor_all,
        'monitor_processes': args.monitor_processes or args.monitor_all,
        'monitor_resources': args.monitor_resources or args.monitor_all,
        'duration': args.duration,
        'watch_paths': []
    }
    
    # Validate watch paths
    if config['monitor_files']:
        if args.watch_paths:
            valid_paths = []
            for path in args.watch_paths:
                if os.path.exists(path):
                    valid_paths.append(path)
                else:
                    print(f"Warning: Path does not exist: {path}")
            config['watch_paths'] = valid_paths
        else:
            config['watch_paths'] = [os.getcwd()]  # Default to current directory
    
    # Validate that at least one monitoring option is selected
    if not any([config['monitor_files'], config['monitor_network'], 
               config['monitor_processes'], config['monitor_resources']]):
        raise ValueError("At least one monitoring option must be specified")
    
    return config


def main():
    """Main function to run the system monitor."""
    parser = argparse.ArgumentParser(
        description='System Monitor Tool - Track legitimate system events',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --monitor-all --duration 300
  %(prog)s --monitor-files --watch-paths /home/user/documents /tmp
  %(prog)s --monitor-network --log-file network_events.log
  %(prog)s --monitor-processes --verbose
        """
    )
    
    # Monitoring options
    parser.add_argument('--monitor-all', action='store_true',
                       help='Monitor all system events (files, network, processes, resources)')
    parser.add_argument('--monitor-files', action='store_true',
                       help='Monitor file system changes')
    parser.add_argument('--monitor-network', action='store_true',
                       help='Monitor network connections')
    parser.add_argument('--monitor-processes', action='store_true',
                       help='Monitor process creation and termination')
    parser.add_argument('--monitor-resources', action='store_true',
                       help='Monitor system resource usage (CPU, memory, disk)')
    
    # Configuration options
    parser.add_argument('--watch-paths', nargs='+', metavar='PATH',
                       help='Paths to monitor for file changes (default: current directory)')
    parser.add_argument('--duration', type=int, metavar='SECONDS',
                       help='Duration to monitor in seconds (default: indefinite)')
    parser.add_argument('--log-file', metavar='FILE',
                       help='Log file path for persistent logging')
    parser.add_argument('--verbose', action='store_true',
                       help='Enable verbose console output')
    
    args = parser.parse_args()
    
    # Check for required dependencies
    if (args.monitor_files or args.monitor_all) and not WATCHDOG_AVAILABLE:
        print("Error: watchdog library is required for file monitoring.")
        print("Install it with: pip install watchdog")
        sys.exit(1)
    
    try:
        # Validate arguments and create configuration
        config = validate_arguments(args)
        
        # Create and start system monitor
        monitor = SystemMonitor(log_file=args.log_file, verbose=args.verbose)
        monitor.start_monitoring(config)
        
    except ValueError as e:
        print(f"Error: {e}")
        parser.print_help()
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nMonitoring stopped by user")
        sys.exit(0)
    except Exception as e:
        print(f"Unexpected error: {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()
