#!/usr/bin/env python3
"""
Memory Information Tool

A Python script that displays comprehensive system memory information including
RAM usage, swap usage, and per-process memory consumption.

Usage:
    python memory_info.py [options]

Examples:
    python memory_info.py                    # Show basic memory info
    python memory_info.py --detailed         # Show detailed memory breakdown
    python memory_info.py --processes 10     # Show top 10 memory-consuming processes
    python memory_info.py --json             # Output in JSON format
    python memory_info.py --monitor 5        # Monitor memory every 5 seconds

Author: Memory Information Tool
License: MIT
"""

import argparse
import json
import os
import platform
import psutil
import sys
import time
from datetime import datetime
from typing import Dict, List, Optional, Tuple


class MemoryInfo:
    """Class to handle memory information gathering and formatting."""
    
    def __init__(self):
        """Initialize the MemoryInfo class."""
        self.system = platform.system()
        
    def get_size_in_gb(self, bytes_value: int) -> float:
        """
        Convert bytes to gigabytes.
        
        Args:
            bytes_value (int): Size in bytes
            
        Returns:
            float: Size in gigabytes rounded to 2 decimal places
        """
        return round(bytes_value / (1024**3), 2)
    
    def get_size_in_mb(self, bytes_value: int) -> float:
        """
        Convert bytes to megabytes.
        
        Args:
            bytes_value (int): Size in bytes
            
        Returns:
            float: Size in megabytes rounded to 2 decimal places
        """
        return round(bytes_value / (1024**2), 2)
    
    def get_basic_memory_info(self) -> Dict:
        """
        Get basic system memory information.
        
        Returns:
            Dict: Dictionary containing basic memory statistics
        """
        try:
            # Get virtual memory information
            virtual_memory = psutil.virtual_memory()
            
            # Get swap memory information
            swap_memory = psutil.swap_memory()
            
            memory_info = {
                'timestamp': datetime.now().isoformat(),
                'system': self.system,
                'virtual_memory': {
                    'total_gb': self.get_size_in_gb(virtual_memory.total),
                    'available_gb': self.get_size_in_gb(virtual_memory.available),
                    'used_gb': self.get_size_in_gb(virtual_memory.used),
                    'free_gb': self.get_size_in_gb(virtual_memory.free),
                    'percentage_used': virtual_memory.percent
                },
                'swap_memory': {
                    'total_gb': self.get_size_in_gb(swap_memory.total),
                    'used_gb': self.get_size_in_gb(swap_memory.used),
                    'free_gb': self.get_size_in_gb(swap_memory.free),
                    'percentage_used': swap_memory.percent
                }
            }
            
            return memory_info
            
        except Exception as e:
            raise RuntimeError(f"Failed to get basic memory info: {e}")
    
    def get_detailed_memory_info(self) -> Dict:
        """
        Get detailed system memory information including buffers and cache.
        
        Returns:
            Dict: Dictionary containing detailed memory statistics
        """
        try:
            basic_info = self.get_basic_memory_info()
            virtual_memory = psutil.virtual_memory()
            
            # Add detailed information
            detailed_info = basic_info.copy()
            detailed_info['virtual_memory'].update({
                'buffers_gb': self.get_size_in_gb(getattr(virtual_memory, 'buffers', 0)),
                'cached_gb': self.get_size_in_gb(getattr(virtual_memory, 'cached', 0)),
                'shared_gb': self.get_size_in_gb(getattr(virtual_memory, 'shared', 0)),
                'active_gb': self.get_size_in_gb(getattr(virtual_memory, 'active', 0)),
                'inactive_gb': self.get_size_in_gb(getattr(virtual_memory, 'inactive', 0))
            })
            
            return detailed_info
            
        except Exception as e:
            raise RuntimeError(f"Failed to get detailed memory info: {e}")
    
    def get_process_memory_info(self, num_processes: int = 10) -> List[Dict]:
        """
        Get memory information for top memory-consuming processes.
        
        Args:
            num_processes (int): Number of top processes to return
            
        Returns:
            List[Dict]: List of dictionaries containing process memory info
        """
        try:
            processes = []
            
            # Iterate through all running processes
            for proc in psutil.process_iter(['pid', 'name', 'memory_info', 'memory_percent']):
                try:
                    proc_info = proc.info
                    if proc_info['memory_info'] is not None:
                        processes.append({
                            'pid': proc_info['pid'],
                            'name': proc_info['name'],
                            'memory_mb': self.get_size_in_mb(proc_info['memory_info'].rss),
                            'memory_percent': round(proc_info['memory_percent'], 2)
                        })
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    # Skip processes that no longer exist or can't be accessed
                    continue
            
            # Sort by memory usage and return top N
            processes.sort(key=lambda x: x['memory_mb'], reverse=True)
            return processes[:num_processes]
            
        except Exception as e:
            raise RuntimeError(f"Failed to get process memory info: {e}")
    
    def format_memory_info(self, memory_info: Dict, show_processes: bool = False, 
                          num_processes: int = 10) -> str:
        """
        Format memory information for display.
        
        Args:
            memory_info (Dict): Memory information dictionary
            show_processes (bool): Whether to include process information
            num_processes (int): Number of processes to show
            
        Returns:
            str: Formatted memory information string
        """
        output = []
        output.append("="*60)
        output.append("SYSTEM MEMORY INFORMATION")
        output.append("="*60)
        output.append(f"Timestamp: {memory_info['timestamp']}")
        output.append(f"System: {memory_info['system']}")
        output.append("")
        
        # Virtual Memory Information
        vm = memory_info['virtual_memory']
        output.append("VIRTUAL MEMORY:")
        output.append(f"  Total:     {vm['total_gb']} GB")
        output.append(f"  Available: {vm['available_gb']} GB")
        output.append(f"  Used:      {vm['used_gb']} GB ({vm['percentage_used']}%)")
        output.append(f"  Free:      {vm['free_gb']} GB")
        
        # Add detailed info if available
        if 'buffers_gb' in vm:
            output.append(f"  Buffers:   {vm['buffers_gb']} GB")
            output.append(f"  Cached:    {vm['cached_gb']} GB")
            if vm['shared_gb'] > 0:
                output.append(f"  Shared:    {vm['shared_gb']} GB")
            if vm['active_gb'] > 0:
                output.append(f"  Active:    {vm['active_gb']} GB")
            if vm['inactive_gb'] > 0:
                output.append(f"  Inactive:  {vm['inactive_gb']} GB")
        
        output.append("")
        
        # Swap Memory Information
        swap = memory_info['swap_memory']
        output.append("SWAP MEMORY:")
        if swap['total_gb'] > 0:
            output.append(f"  Total:     {swap['total_gb']} GB")
            output.append(f"  Used:      {swap['used_gb']} GB ({swap['percentage_used']}%)")
            output.append(f"  Free:      {swap['free_gb']} GB")
        else:
            output.append("  No swap space configured")
        
        # Process Information
        if show_processes:
            output.append("")
            output.append(f"TOP {num_processes} MEMORY-CONSUMING PROCESSES:")
            output.append("-" * 60)
            output.append(f"{'PID':<8} {'NAME':<25} {'MEMORY (MB)':<12} {'MEMORY %':<10}")
            output.append("-" * 60)
            
            processes = self.get_process_memory_info(num_processes)
            for proc in processes:
                output.append(f"{proc['pid']:<8} {proc['name']:<25} {proc['memory_mb']:<12.2f} {proc['memory_percent']:<10.2f}")
        
        return "\n".join(output)


def main():
    """Main function to handle command-line arguments and execute the script."""
    parser = argparse.ArgumentParser(
        description="Display comprehensive system memory information",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                          Show basic memory info
  %(prog)s --detailed               Show detailed memory breakdown
  %(prog)s --processes 10           Show top 10 memory-consuming processes
  %(prog)s --json                   Output in JSON format
  %(prog)s --monitor 5              Monitor memory every 5 seconds
  %(prog)s --detailed --processes 5 Show detailed info with top 5 processes
        """
    )
    
    parser.add_argument(
        '--detailed', '-d',
        action='store_true',
        help='Show detailed memory information including buffers and cache'
    )
    
    parser.add_argument(
        '--processes', '-p',
        type=int,
        metavar='N',
        help='Show top N memory-consuming processes (default: 10)'
    )
    
    parser.add_argument(
        '--json', '-j',
        action='store_true',
        help='Output information in JSON format'
    )
    
    parser.add_argument(
        '--monitor', '-m',
        type=int,
        metavar='SECONDS',
        help='Monitor memory usage every N seconds (Ctrl+C to stop)'
    )
    
    parser.add_argument(
        '--version', '-v',
        action='version',
        version='Memory Information Tool 1.0.0'
    )
    
    args = parser.parse_args()
    
    # Validate arguments
    if args.processes is not None and args.processes < 1:
        print("Error: Number of processes must be at least 1", file=sys.stderr)
        sys.exit(1)
    
    if args.monitor is not None and args.monitor < 1:
        print("Error: Monitor interval must be at least 1 second", file=sys.stderr)
        sys.exit(1)
    
    try:
        memory_tool = MemoryInfo()
        
        # Set default number of processes if --processes flag is used without value
        num_processes = args.processes if args.processes is not None else 10
        show_processes = args.processes is not None
        
        if args.monitor:
            # Monitor mode
            print(f"Monitoring memory usage every {args.monitor} seconds. Press Ctrl+C to stop.\n")
            try:
                while True:
                    # Clear screen (works on most terminals)
                    os.system('clear' if os.name == 'posix' else 'cls')
                    
                    if args.detailed:
                        memory_info = memory_tool.get_detailed_memory_info()
                    else:
                        memory_info = memory_tool.get_basic_memory_info()
                    
                    if args.json:
                        if show_processes:
                            memory_info['processes'] = memory_tool.get_process_memory_info(num_processes)
                        print(json.dumps(memory_info, indent=2))
                    else:
                        formatted_output = memory_tool.format_memory_info(
                            memory_info, show_processes, num_processes
                        )
                        print(formatted_output)
                    
                    time.sleep(args.monitor)
                    
            except KeyboardInterrupt:
                print("\nMonitoring stopped.")
                sys.exit(0)
        
        else:
            # Single execution mode
            if args.detailed:
                memory_info = memory_tool.get_detailed_memory_info()
            else:
                memory_info = memory_tool.get_basic_memory_info()
            
            if args.json:
                if show_processes:
                    memory_info['processes'] = memory_tool.get_process_memory_info(num_processes)
                print(json.dumps(memory_info, indent=2))
            else:
                formatted_output = memory_tool.format_memory_info(
                    memory_info, show_processes, num_processes
                )
                print(formatted_output)
    
    except RuntimeError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(0)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()