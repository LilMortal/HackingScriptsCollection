#!/usr/bin/env python3
"""
Environment Variable Dumper

A Python script that exports, filters, and manages environment variables.
This tool allows you to dump environment variables to various formats,
filter by patterns, and save them to files for backup or analysis purposes.

Usage Examples:
    python env_dumper.py --output json --file env_backup.json
    python env_dumper.py --filter "PATH,HOME" --format table
    python env_dumper.py --exclude "SECRET,TOKEN" --output yaml
    python env_dumper.py --help

Author: Assistant
License: MIT
Version: 1.0.0
"""

import os
import sys
import json
import argparse
import re
from typing import Dict, List, Optional, Union
from pathlib import Path


class EnvironmentVariableDumper:
    """
    A class to handle environment variable operations including
    filtering, formatting, and exporting.
    """
    
    def __init__(self):
        """Initialize the Environment Variable Dumper."""
        self.env_vars: Dict[str, str] = {}
        self.filtered_vars: Dict[str, str] = {}
    
    def load_environment_variables(self) -> None:
        """
        Load all environment variables from the current system.
        """
        try:
            self.env_vars = dict(os.environ)
        except Exception as e:
            raise RuntimeError(f"Failed to load environment variables: {e}")
    
    def filter_variables(self, 
                        include_patterns: Optional[List[str]] = None,
                        exclude_patterns: Optional[List[str]] = None) -> None:
        """
        Filter environment variables based on include/exclude patterns.
        
        Args:
            include_patterns: List of patterns to include (regex supported)
            exclude_patterns: List of patterns to exclude (regex supported)
        """
        self.filtered_vars = self.env_vars.copy()
        
        # Apply include filters
        if include_patterns:
            included_vars = {}
            for pattern in include_patterns:
                try:
                    regex = re.compile(pattern, re.IGNORECASE)
                    for key, value in self.env_vars.items():
                        if regex.search(key):
                            included_vars[key] = value
                except re.error as e:
                    print(f"Warning: Invalid regex pattern '{pattern}': {e}")
                    # Fallback to simple string matching
                    for key, value in self.env_vars.items():
                        if pattern.upper() in key.upper():
                            included_vars[key] = value
            self.filtered_vars = included_vars
        
        # Apply exclude filters
        if exclude_patterns:
            for pattern in exclude_patterns:
                try:
                    regex = re.compile(pattern, re.IGNORECASE)
                    keys_to_remove = [key for key in self.filtered_vars.keys() 
                                    if regex.search(key)]
                except re.error as e:
                    print(f"Warning: Invalid regex pattern '{pattern}': {e}")
                    # Fallback to simple string matching
                    keys_to_remove = [key for key in self.filtered_vars.keys() 
                                    if pattern.upper() in key.upper()]
                
                for key in keys_to_remove:
                    self.filtered_vars.pop(key, None)
    
    def format_as_json(self, indent: int = 2) -> str:
        """
        Format filtered variables as JSON.
        
        Args:
            indent: Number of spaces for JSON indentation
            
        Returns:
            JSON formatted string
        """
        try:
            return json.dumps(self.filtered_vars, indent=indent, sort_keys=True)
        except Exception as e:
            raise ValueError(f"Failed to format as JSON: {e}")
    
    def format_as_yaml(self) -> str:
        """
        Format filtered variables as YAML.
        
        Returns:
            YAML formatted string
        """
        try:
            # Simple YAML formatting without external dependencies
            yaml_lines = []
            for key, value in sorted(self.filtered_vars.items()):
                # Escape special characters and quote if necessary
                if any(char in value for char in ['"', "'", '\n', '\r', '\t']):
                    escaped_value = json.dumps(value)
                else:
                    escaped_value = value
                yaml_lines.append(f"{key}: {escaped_value}")
            return '\n'.join(yaml_lines)
        except Exception as e:
            raise ValueError(f"Failed to format as YAML: {e}")
    
    def format_as_shell(self) -> str:
        """
        Format filtered variables as shell export statements.
        
        Returns:
            Shell export formatted string
        """
        try:
            shell_lines = []
            for key, value in sorted(self.filtered_vars.items()):
                # Escape shell special characters
                escaped_value = value.replace('"', '\\"').replace('$', '\\$')
                shell_lines.append(f'export {key}="{escaped_value}"')
            return '\n'.join(shell_lines)
        except Exception as e:
            raise ValueError(f"Failed to format as shell: {e}")
    
    def format_as_table(self) -> str:
        """
        Format filtered variables as a formatted table.
        
        Returns:
            Table formatted string
        """
        try:
            if not self.filtered_vars:
                return "No environment variables to display."
            
            # Calculate column widths
            max_key_len = max(len(key) for key in self.filtered_vars.keys())
            max_val_len = max(len(str(value)[:100]) for value in self.filtered_vars.values())
            
            # Ensure minimum column widths
            key_width = max(max_key_len, 20)
            val_width = max(max_val_len, 30)
            
            # Create table
            separator = f"+{'-' * (key_width + 2)}+{'-' * (val_width + 2)}+"
            header = f"| {'Variable Name':<{key_width}} | {'Value':<{val_width}} |"
            
            table_lines = [separator, header, separator]
            
            for key, value in sorted(self.filtered_vars.items()):
                # Truncate long values
                display_value = str(value)[:val_width]
                if len(str(value)) > val_width:
                    display_value = display_value[:-3] + "..."
                
                row = f"| {key:<{key_width}} | {display_value:<{val_width}} |"
                table_lines.append(row)
            
            table_lines.append(separator)
            return '\n'.join(table_lines)
        except Exception as e:
            raise ValueError(f"Failed to format as table: {e}")
    
    def save_to_file(self, content: str, filepath: Union[str, Path]) -> None:
        """
        Save content to a file.
        
        Args:
            content: Content to save
            filepath: Path to the output file
        """
        try:
            filepath = Path(filepath)
            filepath.parent.mkdir(parents=True, exist_ok=True)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print(f"Environment variables saved to: {filepath}")
        except Exception as e:
            raise IOError(f"Failed to save file '{filepath}': {e}")
    
    def get_statistics(self) -> Dict[str, int]:
        """
        Get statistics about the environment variables.
        
        Returns:
            Dictionary with statistics
        """
        return {
            'total_variables': len(self.env_vars),
            'filtered_variables': len(self.filtered_vars),
            'filtered_out': len(self.env_vars) - len(self.filtered_vars)
        }


def parse_arguments() -> argparse.Namespace:
    """
    Parse command line arguments.
    
    Returns:
        Parsed arguments namespace
    """
    parser = argparse.ArgumentParser(
        description="Environment Variable Dumper - Export and manage environment variables",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --output json --file env_backup.json
  %(prog)s --filter "PATH,HOME" --format table
  %(prog)s --exclude "SECRET,TOKEN" --output yaml
  %(prog)s --statistics
        """
    )
    
    # Output format options
    output_group = parser.add_mutually_exclusive_group()
    output_group.add_argument(
        '-o', '--output',
        choices=['json', 'yaml', 'shell', 'table'],
        default='table',
        help='Output format (default: table)'
    )
    
    # File output
    parser.add_argument(
        '-f', '--file',
        type=str,
        help='Save output to file instead of stdout'
    )
    
    # Filtering options
    parser.add_argument(
        '--filter', '--include',
        type=str,
        help='Comma-separated list of patterns to include (regex supported)'
    )
    
    parser.add_argument(
        '--exclude',
        type=str,
        help='Comma-separated list of patterns to exclude (regex supported)'
    )
    
    # Utility options
    parser.add_argument(
        '--statistics', '--stats',
        action='store_true',
        help='Display statistics about environment variables'
    )
    
    parser.add_argument(
        '--count',
        action='store_true',
        help='Display only the count of matching variables'
    )
    
    parser.add_argument(
        '--quiet', '-q',
        action='store_true',
        help='Suppress informational messages'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version='Environment Variable Dumper 1.0.0'
    )
    
    return parser.parse_args()


def main() -> None:
    """
    Main function to execute the environment variable dumper.
    """
    try:
        # Parse command line arguments
        args = parse_arguments()
        
        # Initialize dumper
        dumper = EnvironmentVariableDumper()
        
        # Load environment variables
        dumper.load_environment_variables()
        
        # Parse filter patterns
        include_patterns = None
        exclude_patterns = None
        
        if args.filter:
            include_patterns = [pattern.strip() for pattern in args.filter.split(',')]
        
        if args.exclude:
            exclude_patterns = [pattern.strip() for pattern in args.exclude.split(',')]
        
        # Apply filters
        dumper.filter_variables(include_patterns, exclude_patterns)
        
        # Handle statistics request
        if args.statistics:
            stats = dumper.get_statistics()
            print("Environment Variable Statistics:")
            print(f"  Total variables: {stats['total_variables']}")
            print(f"  Filtered variables: {stats['filtered_variables']}")
            print(f"  Filtered out: {stats['filtered_out']}")
            return
        
        # Handle count request
        if args.count:
            print(len(dumper.filtered_vars))
            return
        
        # Format output
        if args.output == 'json':
            content = dumper.format_as_json()
        elif args.output == 'yaml':
            content = dumper.format_as_yaml()
        elif args.output == 'shell':
            content = dumper.format_as_shell()
        else:  # table
            content = dumper.format_as_table()
        
        # Output to file or stdout
        if args.file:
            dumper.save_to_file(content, args.file)
        else:
            print(content)
        
        # Display summary if not quiet
        if not args.quiet and not args.file:
            stats = dumper.get_statistics()
            print(f"\n--- Summary: {stats['filtered_variables']} variables displayed ---")
    
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
