#!/usr/bin/env python3
"""
SSH Client Wrapper - A secure and user-friendly SSH client interface

This script provides a wrapper around SSH functionality for legitimate remote
system administration tasks. It includes proper authentication, error handling,
and logging capabilities.

Usage:
    python ssh_client_wrapper.py -H hostname -u username -c "ls -la"
    python ssh_client_wrapper.py -H 192.168.1.100 -u admin -k ~/.ssh/id_rsa -c "uptime"
    python ssh_client_wrapper.py -H server.example.com -u user -p -c "df -h"

Author: System Administrator
License: MIT
"""

import argparse
import sys
import logging
import getpass
import os
from pathlib import Path
import socket
import threading
import time

try:
    import paramiko
    PARAMIKO_AVAILABLE = True
except ImportError:
    PARAMIKO_AVAILABLE = False


class SSHClientWrapper:
    """
    A wrapper class for SSH client operations with enhanced security and logging.
    """
    
    def __init__(self, hostname, username, port=22, timeout=30):
        """
        Initialize the SSH client wrapper.
        
        Args:
            hostname (str): Remote host to connect to
            username (str): Username for authentication
            port (int): SSH port (default: 22)
            timeout (int): Connection timeout in seconds (default: 30)
        """
        self.hostname = hostname
        self.username = username
        self.port = port
        self.timeout = timeout
        self.client = None
        self.logger = self._setup_logger()
        
    def _setup_logger(self):
        """Set up logging configuration."""
        logger = logging.getLogger('ssh_wrapper')
        logger.setLevel(logging.INFO)
        
        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            
        return logger
        
    def _validate_hostname(self):
        """
        Validate hostname format and reachability.
        
        Returns:
            bool: True if hostname is valid and reachable
        """
        try:
            # Basic hostname validation
            if not self.hostname or len(self.hostname) > 253:
                return False
                
            # Test if hostname is reachable
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((self.hostname, self.port))
            sock.close()
            
            return result == 0
            
        except Exception as e:
            self.logger.error(f"Hostname validation failed: {e}")
            return False
            
    def connect_with_password(self, password):
        """
        Connect to SSH server using password authentication.
        
        Args:
            password (str): Password for authentication
            
        Returns:
            bool: True if connection successful
        """
        try:
            if not self._validate_hostname():
                self.logger.error(f"Cannot reach {self.hostname}:{self.port}")
                return False
                
            self.client = paramiko.SSHClient()
            self.client.set_missing_host_key_policy(paramiko.AutoAddHostKeyPolicy())
            
            self.logger.info(f"Connecting to {self.hostname}:{self.port} as {self.username}")
            
            self.client.connect(
                hostname=self.hostname,
                port=self.port,
                username=self.username,
                password=password,
                timeout=self.timeout
            )
            
            self.logger.info("Successfully connected via password authentication")
            return True
            
        except paramiko.AuthenticationException:
            self.logger.error("Authentication failed - invalid credentials")
            return False
        except paramiko.SSHException as e:
            self.logger.error(f"SSH connection error: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
            
    def connect_with_key(self, key_path):
        """
        Connect to SSH server using key-based authentication.
        
        Args:
            key_path (str): Path to private key file
            
        Returns:
            bool: True if connection successful
        """
        try:
            if not self._validate_hostname():
                self.logger.error(f"Cannot reach {self.hostname}:{self.port}")
                return False
                
            # Validate key file exists and is readable
            key_file = Path(key_path).expanduser()
            if not key_file.exists():
                self.logger.error(f"Key file not found: {key_path}")
                return False
                
            if not os.access(key_file, os.R_OK):
                self.logger.error(f"Cannot read key file: {key_path}")
                return False
                
            self.client = paramiko.SSHClient()
            self.client.set_missing_host_key_policy(paramiko.AutoAddHostKeyPolicy())
            
            self.logger.info(f"Connecting to {self.hostname}:{self.port} as {self.username} with key")
            
            self.client.connect(
                hostname=self.hostname,
                port=self.port,
                username=self.username,
                key_filename=str(key_file),
                timeout=self.timeout
            )
            
            self.logger.info("Successfully connected via key authentication")
            return True
            
        except paramiko.AuthenticationException:
            self.logger.error("Authentication failed - invalid key or permissions")
            return False
        except paramiko.SSHException as e:
            self.logger.error(f"SSH connection error: {e}")
            return False
        except Exception as e:
            self.logger.error(f"Connection failed: {e}")
            return False
            
    def execute_command(self, command, timeout=30):
        """
        Execute a command on the remote server.
        
        Args:
            command (str): Command to execute
            timeout (int): Command timeout in seconds
            
        Returns:
            dict: Result containing stdout, stderr, and exit_code
        """
        if not self.client:
            self.logger.error("Not connected to SSH server")
            return None
            
        try:
            # Input validation - prevent potentially dangerous commands
            dangerous_patterns = ['rm -rf /', 'mkfs', 'dd if=', 'shutdown', 'reboot']
            if any(pattern in command.lower() for pattern in dangerous_patterns):
                self.logger.warning(f"Potentially dangerous command blocked: {command}")
                return {
                    'stdout': '',
                    'stderr': 'Command blocked for safety',
                    'exit_code': 1
                }
            
            self.logger.info(f"Executing command: {command}")
            
            stdin, stdout, stderr = self.client.exec_command(command, timeout=timeout)
            
            # Read output
            stdout_data = stdout.read().decode('utf-8')
            stderr_data = stderr.read().decode('utf-8')
            exit_code = stdout.channel.recv_exit_status()
            
            result = {
                'stdout': stdout_data,
                'stderr': stderr_data,
                'exit_code': exit_code
            }
            
            self.logger.info(f"Command completed with exit code: {exit_code}")
            return result
            
        except paramiko.SSHException as e:
            self.logger.error(f"SSH execution error: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Command execution failed: {e}")
            return None
            
    def transfer_file(self, local_path, remote_path, upload=True):
        """
        Transfer files between local and remote systems.
        
        Args:
            local_path (str): Local file path
            remote_path (str): Remote file path
            upload (bool): True for upload, False for download
            
        Returns:
            bool: True if transfer successful
        """
        if not self.client:
            self.logger.error("Not connected to SSH server")
            return False
            
        try:
            sftp = self.client.open_sftp()
            
            if upload:
                if not Path(local_path).exists():
                    self.logger.error(f"Local file not found: {local_path}")
                    return False
                    
                self.logger.info(f"Uploading {local_path} to {remote_path}")
                sftp.put(local_path, remote_path)
                self.logger.info("Upload completed successfully")
            else:
                self.logger.info(f"Downloading {remote_path} to {local_path}")
                sftp.get(remote_path, local_path)
                self.logger.info("Download completed successfully")
                
            sftp.close()
            return True
            
        except Exception as e:
            self.logger.error(f"File transfer failed: {e}")
            return False
            
    def disconnect(self):
        """Close the SSH connection."""
        if self.client:
            self.client.close()
            self.logger.info("SSH connection closed")


def main():
    """Main function to handle command-line interface."""
    parser = argparse.ArgumentParser(
        description='SSH Client Wrapper for secure remote administration',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -H server.com -u admin -p -c "uptime"
  %(prog)s -H 192.168.1.100 -u root -k ~/.ssh/id_rsa -c "df -h"
  %(prog)s -H server.com -u user -p --upload /local/file.txt /remote/file.txt
        """
    )
    
    # Required arguments
    parser.add_argument('-H', '--hostname', required=True,
                       help='Remote hostname or IP address')
    parser.add_argument('-u', '--username', required=True,
                       help='Username for authentication')
    
    # Authentication options
    auth_group = parser.add_mutually_exclusive_group(required=True)
    auth_group.add_argument('-p', '--password', action='store_true',
                           help='Use password authentication (will prompt)')
    auth_group.add_argument('-k', '--key', metavar='PATH',
                           help='Path to private key file')
    
    # Optional arguments
    parser.add_argument('--port', type=int, default=22,
                       help='SSH port (default: 22)')
    parser.add_argument('--timeout', type=int, default=30,
                       help='Connection timeout in seconds (default: 30)')
    parser.add_argument('-c', '--command',
                       help='Command to execute on remote server')
    parser.add_argument('--upload', nargs=2, metavar=('LOCAL', 'REMOTE'),
                       help='Upload file: local_path remote_path')
    parser.add_argument('--download', nargs=2, metavar=('REMOTE', 'LOCAL'),
                       help='Download file: remote_path local_path')
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Enable verbose logging')
    
    args = parser.parse_args()
    
    # Check for paramiko availability
    if not PARAMIKO_AVAILABLE:
        print("Error: paramiko library not found. Please install it with:")
        print("pip install paramiko")
        sys.exit(1)
    
    # Set up logging level
    if args.verbose:
        logging.getLogger('ssh_wrapper').setLevel(logging.DEBUG)
    
    # Create SSH client wrapper
    ssh_client = SSHClientWrapper(
        hostname=args.hostname,
        username=args.username,
        port=args.port,
        timeout=args.timeout
    )
    
    # Connect based on authentication method
    connected = False
    
    if args.password:
        password = getpass.getpass(f"Password for {args.username}@{args.hostname}: ")
        connected = ssh_client.connect_with_password(password)
    elif args.key:
        connected = ssh_client.connect_with_key(args.key)
    
    if not connected:
        print("Failed to connect to SSH server")
        sys.exit(1)
    
    try:
        # Execute command if provided
        if args.command:
            result = ssh_client.execute_command(args.command)
            if result:
                if result['stdout']:
                    print("STDOUT:")
                    print(result['stdout'])
                if result['stderr']:
                    print("STDERR:")
                    print(result['stderr'])
                print(f"Exit Code: {result['exit_code']}")
                sys.exit(result['exit_code'])
            else:
                sys.exit(1)
        
        # Handle file transfers
        elif args.upload:
            success = ssh_client.transfer_file(args.upload[0], args.upload[1], upload=True)
            sys.exit(0 if success else 1)
            
        elif args.download:
            success = ssh_client.transfer_file(args.download[1], args.download[0], upload=False)
            sys.exit(0 if success else 1)
            
        else:
            print("No operation specified. Use -c for command, --upload, or --download")
            sys.exit(1)
            
    finally:
        ssh_client.disconnect()


if __name__ == '__main__':
    main()
