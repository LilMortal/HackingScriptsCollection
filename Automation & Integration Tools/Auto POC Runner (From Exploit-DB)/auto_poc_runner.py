#!/usr/bin/env python3
"""
Auto POC Runner - Automated Proof of Concept Script Execution Tool

This script provides a safe and automated way to execute Proof of Concept (PoC) scripts
with proper logging, timeout handling, and safety features. It's designed for security
researchers and developers who need to run multiple PoC scripts systematically.

Usage:
    python auto_poc_runner.py --target example.com --script-dir ./poc_scripts
    python auto_poc_runner.py --config config.json --output-dir ./results
    python auto_poc_runner.py --single-script exploit.py --target 192.168.1.1 --timeout 30

Author: Auto POC Runner
License: MIT
Version: 1.0.0
"""

import argparse
import json
import logging
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import threading
import signal


class POCRunner:
    """
    Main class for managing and executing Proof of Concept scripts.
    
    This class handles script discovery, execution, logging, and result collection
    with proper safety measures and timeout handling.
    """
    
    def __init__(self, config: Dict):
        """
        Initialize the POC Runner with configuration.
        
        Args:
            config (Dict): Configuration dictionary containing runner settings
        """
        self.config = config
        self.results = []
        self.logger = self._setup_logging()
        self.running_processes = []
        
        # Setup signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _setup_logging(self) -> logging.Logger:
        """
        Setup logging configuration for the POC runner.
        
        Returns:
            logging.Logger: Configured logger instance
        """
        log_level = getattr(logging, self.config.get('log_level', 'INFO').upper())
        log_format = '%(asctime)s - %(levelname)s - %(message)s'
        
        # Create logs directory if it doesn't exist
        log_dir = Path(self.config.get('output_dir', './results')) / 'logs'
        log_dir.mkdir(parents=True, exist_ok=True)
        
        # Setup file and console logging
        logging.basicConfig(
            level=log_level,
            format=log_format,
            handlers=[
                logging.FileHandler(log_dir / f"poc_runner_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        return logging.getLogger(__name__)
    
    def _signal_handler(self, signum, frame):
        """
        Handle interrupt signals gracefully.
        
        Args:
            signum: Signal number
            frame: Current stack frame
        """
        self.logger.warning(f"Received signal {signum}. Shutting down gracefully...")
        self._cleanup_processes()
        sys.exit(1)
    
    def _cleanup_processes(self):
        """Clean up any running processes."""
        for process in self.running_processes:
            if process.poll() is None:
                self.logger.info(f"Terminating process PID: {process.pid}")
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    process.kill()
    
    def discover_scripts(self, script_dir: str) -> List[Path]:
        """
        Discover executable scripts in the specified directory.
        
        Args:
            script_dir (str): Directory path to search for scripts
            
        Returns:
            List[Path]: List of discovered script paths
        """
        script_path = Path(script_dir)
        if not script_path.exists():
            raise FileNotFoundError(f"Script directory not found: {script_dir}")
        
        # Look for common script extensions
        extensions = {'.py', '.sh', '.pl', '.rb', '.js'}
        scripts = []
        
        for file_path in script_path.rglob('*'):
            if file_path.is_file() and file_path.suffix.lower() in extensions:
                # Check if file is executable or is a Python script
                if os.access(file_path, os.X_OK) or file_path.suffix.lower() == '.py':
                    scripts.append(file_path)
        
        self.logger.info(f"Discovered {len(scripts)} executable scripts in {script_dir}")
        return sorted(scripts)
    
    def _prepare_command(self, script_path: Path, target: str) -> List[str]:
        """
        Prepare the command to execute a script.
        
        Args:
            script_path (Path): Path to the script to execute
            target (str): Target for the PoC script
            
        Returns:
            List[str]: Command as a list of strings
        """
        cmd = []
        
        # Determine interpreter based on file extension
        if script_path.suffix.lower() == '.py':
            cmd.extend([sys.executable, str(script_path)])
        elif script_path.suffix.lower() == '.sh':
            cmd.extend(['bash', str(script_path)])
        elif script_path.suffix.lower() == '.pl':
            cmd.extend(['perl', str(script_path)])
        elif script_path.suffix.lower() == '.rb':
            cmd.extend(['ruby', str(script_path)])
        elif script_path.suffix.lower() == '.js':
            cmd.extend(['node', str(script_path)])
        else:
            cmd.append(str(script_path))
        
        # Add target as argument
        cmd.append(target)
        
        # Add any additional arguments from config
        if 'script_args' in self.config:
            cmd.extend(self.config['script_args'])
        
        return cmd
    
    def execute_script(self, script_path: Path, target: str) -> Dict:
        """
        Execute a single PoC script against a target.
        
        Args:
            script_path (Path): Path to the script to execute
            target (str): Target for the PoC script
            
        Returns:
            Dict: Execution result containing status, output, and metadata
        """
        start_time = time.time()
        result = {
            'script': str(script_path),
            'target': target,
            'start_time': datetime.now().isoformat(),
            'status': 'unknown',
            'output': '',
            'error': '',
            'execution_time': 0,
            'timeout': False
        }
        
        try:
            cmd = self._prepare_command(script_path, target)
            self.logger.info(f"Executing: {' '.join(cmd)}")
            
            # Execute with timeout
            timeout = self.config.get('timeout', 30)
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                cwd=script_path.parent if self.config.get('use_script_dir', True) else None
            )
            
            self.running_processes.append(process)
            
            try:
                stdout, stderr = process.communicate(timeout=timeout)
                result['output'] = stdout
                result['error'] = stderr
                result['status'] = 'success' if process.returncode == 0 else 'failed'
                result['return_code'] = process.returncode
                
            except subprocess.TimeoutExpired:
                process.kill()
                result['status'] = 'timeout'
                result['timeout'] = True
                result['error'] = f'Script execution timed out after {timeout} seconds'
                self.logger.warning(f"Script {script_path.name} timed out after {timeout}s")
            
            finally:
                if process in self.running_processes:
                    self.running_processes.remove(process)
        
        except Exception as e:
            result['status'] = 'error'
            result['error'] = str(e)
            self.logger.error(f"Error executing {script_path.name}: {e}")
        
        finally:
            result['execution_time'] = time.time() - start_time
            result['end_time'] = datetime.now().isoformat()
        
        return result
    
    def run_single_script(self, script_path: str, target: str) -> Dict:
        """
        Run a single PoC script.
        
        Args:
            script_path (str): Path to the script to execute
            target (str): Target for the PoC script
            
        Returns:
            Dict: Execution result
        """
        script = Path(script_path)
        if not script.exists():
            raise FileNotFoundError(f"Script not found: {script_path}")
        
        self.logger.info(f"Running single script: {script.name} against {target}")
        result = self.execute_script(script, target)
        self.results.append(result)
        
        return result
    
    def run_batch(self, script_dir: str, targets: List[str]) -> List[Dict]:
        """
        Run multiple PoC scripts against multiple targets.
        
        Args:
            script_dir (str): Directory containing PoC scripts
            targets (List[str]): List of targets to test
            
        Returns:
            List[Dict]: List of execution results
        """
        scripts = self.discover_scripts(script_dir)
        
        if not scripts:
            self.logger.warning(f"No executable scripts found in {script_dir}")
            return []
        
        self.logger.info(f"Running {len(scripts)} scripts against {len(targets)} targets")
        
        for script in scripts:
            for target in targets:
                self.logger.info(f"Testing {script.name} against {target}")
                result = self.execute_script(script, target)
                self.results.append(result)
                
                # Optional delay between executions
                delay = self.config.get('delay_between_tests', 0)
                if delay > 0:
                    time.sleep(delay)
        
        return self.results
    
    def save_results(self, output_file: Optional[str] = None):
        """
        Save execution results to a JSON file.
        
        Args:
            output_file (Optional[str]): Output file path. If None, uses default naming.
        """
        if not self.results:
            self.logger.warning("No results to save")
            return
        
        if output_file is None:
            output_dir = Path(self.config.get('output_dir', './results'))
            output_dir.mkdir(parents=True, exist_ok=True)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_file = output_dir / f"poc_results_{timestamp}.json"
        
        try:
            with open(output_file, 'w') as f:
                json.dump({
                    'metadata': {
                        'total_tests': len(self.results),
                        'timestamp': datetime.now().isoformat(),
                        'config': self.config
                    },
                    'results': self.results
                }, f, indent=2)
            
            self.logger.info(f"Results saved to: {output_file}")
            
        except Exception as e:
            self.logger.error(f"Failed to save results: {e}")
    
    def print_summary(self):
        """Print a summary of the execution results."""
        if not self.results:
            print("No results to summarize")
            return
        
        total = len(self.results)
        successful = sum(1 for r in self.results if r['status'] == 'success')
        failed = sum(1 for r in self.results if r['status'] == 'failed')
        timeouts = sum(1 for r in self.results if r['status'] == 'timeout')
        errors = sum(1 for r in self.results if r['status'] == 'error')
        
        print("\n" + "="*50)
        print("EXECUTION SUMMARY")
        print("="*50)
        print(f"Total tests run: {total}")
        print(f"Successful: {successful}")
        print(f"Failed: {failed}")
        print(f"Timeouts: {timeouts}")
        print(f"Errors: {errors}")
        print(f"Success rate: {(successful/total)*100:.1f}%")
        print("="*50)


def load_config(config_file: str) -> Dict:
    """
    Load configuration from a JSON file.
    
    Args:
        config_file (str): Path to the configuration file
        
    Returns:
        Dict: Configuration dictionary
    """
    try:
        with open(config_file, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"Configuration file not found: {config_file}")
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON in configuration file: {e}")


def validate_target(target: str) -> bool:
    """
    Basic validation for target format.
    
    Args:
        target (str): Target to validate
        
    Returns:
        bool: True if target appears valid
    """
    # Basic validation - could be enhanced with more sophisticated checks
    if not target or len(target.strip()) == 0:
        return False
    
    # Check for obviously malicious patterns
    dangerous_chars = [';', '|', '&', '`', ', '(', ')']
    if any(char in target for char in dangerous_chars):
        return False
    
    return True


def main():
    """Main function to handle command-line interface and script execution."""
    parser = argparse.ArgumentParser(
        description="Auto POC Runner - Automated Proof of Concept Script Execution Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --target example.com --script-dir ./poc_scripts
  %(prog)s --config config.json --output-dir ./results
  %(prog)s --single-script exploit.py --target 192.168.1.1 --timeout 30
  %(prog)s --targets-file targets.txt --script-dir ./exploits --delay 2
        """
    )
    
    # Input options
    parser.add_argument('--target', type=str, help='Single target to test')
    parser.add_argument('--targets-file', type=str, help='File containing list of targets (one per line)')
    parser.add_argument('--script-dir', type=str, help='Directory containing PoC scripts')
    parser.add_argument('--single-script', type=str, help='Path to a single script to execute')
    parser.add_argument('--config', type=str, help='JSON configuration file')
    
    # Execution options
    parser.add_argument('--timeout', type=int, default=30, help='Timeout for script execution (seconds)')
    parser.add_argument('--delay', type=int, default=0, help='Delay between tests (seconds)')
    parser.add_argument('--output-dir', type=str, default='./results', help='Output directory for results')
    
    # Logging options
    parser.add_argument('--log-level', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'], 
                       default='INFO', help='Logging level')
    parser.add_argument('--quiet', action='store_true', help='Suppress output except errors')
    
    # Safety options
    parser.add_argument('--dry-run', action='store_true', help='Show what would be executed without running')
    
    args = parser.parse_args()
    
    try:
        # Load configuration
        config = {}
        if args.config:
            config = load_config(args.config)
        
        # Override config with command-line arguments
        config.update({
            'timeout': args.timeout,
            'delay_between_tests': args.delay,
            'output_dir': args.output_dir,
            'log_level': 'ERROR' if args.quiet else args.log_level,
            'dry_run': args.dry_run
        })
        
        # Determine targets
        targets = []
        if args.target:
            if not validate_target(args.target):
                raise ValueError(f"Invalid target format: {args.target}")
            targets = [args.target]
        elif args.targets_file:
            if not os.path.exists(args.targets_file):
                raise FileNotFoundError(f"Targets file not found: {args.targets_file}")
            with open(args.targets_file, 'r') as f:
                targets = [line.strip() for line in f if line.strip()]
                targets = [t for t in targets if validate_target(t)]
        else:
            raise ValueError("Either --target or --targets-file must be specified")
        
        if not targets:
            raise ValueError("No valid targets found")
        
        # Initialize POC Runner
        runner = POCRunner(config)
        
        # Execute based on mode
        if args.single_script:
            if len(targets) != 1:
                raise ValueError("Single script mode requires exactly one target")
            
            if args.dry_run:
                print(f"Would execute: {args.single_script} against {targets[0]}")
                return
            
            result = runner.run_single_script(args.single_script, targets[0])
            print(f"Script execution completed with status: {result['status']}")
            
        elif args.script_dir:
            if args.dry_run:
                scripts = runner.discover_scripts(args.script_dir)
                print(f"Would execute {len(scripts)} scripts against {len(targets)} targets:")
                for script in scripts:
                    for target in targets:
                        print(f"  {script.name} -> {target}")
                return
            
            runner.run_batch(args.script_dir, targets)
        else:
            raise ValueError("Either --single-script or --script-dir must be specified")
        
        # Save results and print summary
        if not args.dry_run:
            runner.save_results()
            if not args.quiet:
                runner.print_summary()
    
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()