#!/usr/bin/env python3
"""
Telegram Bot for Pentesting Reports

A Python script that creates a Telegram bot to send structured penetration testing
reports to authorized channels or users. This tool helps security professionals
share findings and collaborate on security assessments.

Usage:
    python telegram_pentest_bot.py --token YOUR_BOT_TOKEN --chat-id CHAT_ID
    python telegram_pentest_bot.py --config config.json
    python telegram_pentest_bot.py --interactive

Author: Security Professional
License: MIT
Version: 1.0.0
"""

import argparse
import json
import logging
import os
import sys
from datetime import datetime
from typing import Dict, List, Optional, Union
import asyncio
import re

# External dependencies
try:
    import aiohttp
    from aiofiles import open as aio_open
except ImportError as e:
    print(f"Missing required dependencies: {e}")
    print("Please install with: pip install aiohttp aiofiles")
    sys.exit(1)


class TelegramBot:
    """
    Telegram Bot class for sending pentesting reports.
    
    This class handles authentication, message formatting, and report delivery
    through the Telegram Bot API.
    """
    
    def __init__(self, token: str):
        """
        Initialize the Telegram bot.
        
        Args:
            token (str): Telegram bot token from BotFather
        """
        self.token = token
        self.base_url = f"https://api.telegram.org/bot{token}"
        self.session = None
        
        # Set up logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
    
    async def __aenter__(self):
        """Async context manager entry."""
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        if self.session:
            await self.session.close()
    
    async def send_message(self, chat_id: Union[str, int], text: str, 
                          parse_mode: str = "Markdown") -> bool:
        """
        Send a text message to a Telegram chat.
        
        Args:
            chat_id: Telegram chat ID or username
            text: Message text to send
            parse_mode: Message formatting mode (Markdown or HTML)
            
        Returns:
            bool: True if message sent successfully, False otherwise
        """
        url = f"{self.base_url}/sendMessage"
        data = {
            "chat_id": chat_id,
            "text": text,
            "parse_mode": parse_mode
        }
        
        try:
            async with self.session.post(url, json=data) as response:
                if response.status == 200:
                    self.logger.info(f"Message sent successfully to {chat_id}")
                    return True
                else:
                    error_text = await response.text()
                    self.logger.error(f"Failed to send message: {error_text}")
                    return False
        except Exception as e:
            self.logger.error(f"Error sending message: {e}")
            return False
    
    async def send_document(self, chat_id: Union[str, int], 
                           file_path: str, caption: str = "") -> bool:
        """
        Send a document to a Telegram chat.
        
        Args:
            chat_id: Telegram chat ID or username
            file_path: Path to the file to send
            caption: Optional caption for the document
            
        Returns:
            bool: True if document sent successfully, False otherwise
        """
        if not os.path.exists(file_path):
            self.logger.error(f"File not found: {file_path}")
            return False
        
        url = f"{self.base_url}/sendDocument"
        
        try:
            with open(file_path, 'rb') as file:
                data = aiohttp.FormData()
                data.add_field('chat_id', str(chat_id))
                data.add_field('document', file, filename=os.path.basename(file_path))
                if caption:
                    data.add_field('caption', caption)
                
                async with self.session.post(url, data=data) as response:
                    if response.status == 200:
                        self.logger.info(f"Document sent successfully to {chat_id}")
                        return True
                    else:
                        error_text = await response.text()
                        self.logger.error(f"Failed to send document: {error_text}")
                        return False
        except Exception as e:
            self.logger.error(f"Error sending document: {e}")
            return False
    
    async def verify_bot_token(self) -> bool:
        """
        Verify that the bot token is valid.
        
        Returns:
            bool: True if token is valid, False otherwise
        """
        url = f"{self.base_url}/getMe"
        
        try:
            async with self.session.get(url) as response:
                if response.status == 200:
                    bot_info = await response.json()
                    self.logger.info(f"Bot verified: {bot_info['result']['username']}")
                    return True
                else:
                    self.logger.error("Invalid bot token")
                    return False
        except Exception as e:
            self.logger.error(f"Error verifying bot token: {e}")
            return False


class PentestReport:
    """
    Class for creating and formatting penetration testing reports.
    
    This class handles the structure and formatting of pentest findings
    for delivery through Telegram.
    """
    
    def __init__(self):
        """Initialize the pentest report."""
        self.findings = []
        self.metadata = {
            "target": "",
            "tester": "",
            "date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "scope": "",
            "methodology": ""
        }
    
    def set_metadata(self, target: str, tester: str, scope: str, 
                    methodology: str = "OWASP Testing Guide") -> None:
        """
        Set report metadata.
        
        Args:
            target: Target system or application
            tester: Name of the security tester
            scope: Testing scope description
            methodology: Testing methodology used
        """
        self.metadata.update({
            "target": target,
            "tester": tester,
            "scope": scope,
            "methodology": methodology
        })
    
    def add_finding(self, title: str, severity: str, description: str, 
                   impact: str, recommendation: str, cvss_score: float = 0.0) -> None:
        """
        Add a security finding to the report.
        
        Args:
            title: Finding title
            severity: Severity level (Critical, High, Medium, Low, Info)
            description: Detailed description of the finding
            impact: Business impact description
            recommendation: Remediation recommendations
            cvss_score: CVSS score (0.0-10.0)
        """
        # Validate severity
        valid_severities = ["Critical", "High", "Medium", "Low", "Info"]
        if severity not in valid_severities:
            raise ValueError(f"Invalid severity. Must be one of: {valid_severities}")
        
        # Validate CVSS score
        if not 0.0 <= cvss_score <= 10.0:
            raise ValueError("CVSS score must be between 0.0 and 10.0")
        
        finding = {
            "id": len(self.findings) + 1,
            "title": title,
            "severity": severity,
            "description": description,
            "impact": impact,
            "recommendation": recommendation,
            "cvss_score": cvss_score,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        
        self.findings.append(finding)
    
    def generate_summary(self) -> str:
        """
        Generate a summary of the penetration test results.
        
        Returns:
            str: Formatted summary text
        """
        severity_counts = {"Critical": 0, "High": 0, "Medium": 0, "Low": 0, "Info": 0}
        for finding in self.findings:
            severity_counts[finding["severity"]] += 1
        
        summary = f"""
üîí **Penetration Test Summary**

**Target:** {self.metadata['target']}
**Tester:** {self.metadata['tester']}
**Date:** {self.metadata['date']}
**Scope:** {self.metadata['scope']}
**Methodology:** {self.metadata['methodology']}

**Findings Summary:**
üî¥ Critical: {severity_counts['Critical']}
üü† High: {severity_counts['High']}
üü° Medium: {severity_counts['Medium']}
üîµ Low: {severity_counts['Low']}
‚ö™ Info: {severity_counts['Info']}

**Total Findings:** {len(self.findings)}
        """.strip()
        
        return summary
    
    def format_finding(self, finding_id: int) -> str:
        """
        Format a specific finding for Telegram delivery.
        
        Args:
            finding_id: ID of the finding to format
            
        Returns:
            str: Formatted finding text
        """
        if finding_id < 1 or finding_id > len(self.findings):
            raise ValueError(f"Invalid finding ID: {finding_id}")
        
        finding = self.findings[finding_id - 1]
        
        # Severity emoji mapping
        severity_emojis = {
            "Critical": "üî¥",
            "High": "üü†",
            "Medium": "üü°",
            "Low": "üîµ",
            "Info": "‚ö™"
        }
        
        formatted = f"""
{severity_emojis[finding['severity']]} **Finding #{finding['id']}: {finding['title']}**

**Severity:** {finding['severity']}
**CVSS Score:** {finding['cvss_score']}/10.0

**Description:**
{finding['description']}

**Impact:**
{finding['impact']}

**Recommendation:**
{finding['recommendation']}

**Discovered:** {finding['timestamp']}
        """.strip()
        
        return formatted
    
    def export_to_json(self, filename: str) -> bool:
        """
        Export the report to a JSON file.
        
        Args:
            filename: Output filename
            
        Returns:
            bool: True if export successful, False otherwise
        """
        try:
            report_data = {
                "metadata": self.metadata,
                "findings": self.findings,
                "generated_at": datetime.now().isoformat()
            }
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, indent=2, ensure_ascii=False)
            
            return True
        except Exception as e:
            logging.error(f"Error exporting to JSON: {e}")
            return False


def load_config(config_path: str) -> Dict:
    """
    Load configuration from a JSON file.
    
    Args:
        config_path: Path to the configuration file
        
    Returns:
        dict: Configuration data
    """
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        logging.error(f"Configuration file not found: {config_path}")
        return {}
    except json.JSONDecodeError as e:
        logging.error(f"Invalid JSON in configuration file: {e}")
        return {}


def validate_inputs(token: str, chat_id: str) -> bool:
    """
    Validate bot token and chat ID formats.
    
    Args:
        token: Telegram bot token
        chat_id: Telegram chat ID
        
    Returns:
        bool: True if inputs are valid, False otherwise
    """
    # Basic token format validation (should contain numbers and letters)
    if not re.match(r'^[0-9]+:[A-Za-z0-9_-]+$', token):
        logging.error("Invalid bot token format")
        return False
    
    # Chat ID can be numeric or start with @ for usernames
    if not (chat_id.isdigit() or chat_id.lstrip('-').isdigit() or chat_id.startswith('@')):
        logging.error("Invalid chat ID format")
        return False
    
    return True


async def interactive_mode():
    """Run the bot in interactive mode for creating reports."""
    print("üîí Telegram Pentest Bot - Interactive Mode")
    print("=" * 50)
    
    # Get bot credentials
    token = input("Enter your Telegram bot token: ").strip()
    chat_id = input("Enter the chat ID or username: ").strip()
    
    if not validate_inputs(token, chat_id):
        print("‚ùå Invalid inputs provided")
        return
    
    # Initialize bot and report
    async with TelegramBot(token) as bot:
        if not await bot.verify_bot_token():
            print("‚ùå Bot token verification failed")
            return
        
        report = PentestReport()
        
        # Get report metadata
        print("\nüìã Report Metadata")
        target = input("Target system/application: ").strip()
        tester = input("Tester name: ").strip()
        scope = input("Testing scope: ").strip()
        methodology = input("Methodology (default: OWASP Testing Guide): ").strip()
        
        if not methodology:
            methodology = "OWASP Testing Guide"
        
        report.set_metadata(target, tester, scope, methodology)
        
        # Add findings
        print("\nüîç Adding Findings")
        while True:
            print("\nAdd a new finding:")
            title = input("Finding title: ").strip()
            if not title:
                break
            
            print("Severity options: Critical, High, Medium, Low, Info")
            severity = input("Severity: ").strip()
            
            description = input("Description: ").strip()
            impact = input("Impact: ").strip()
            recommendation = input("Recommendation: ").strip()
            
            try:
                cvss_input = input("CVSS Score (0.0-10.0, default: 0.0): ").strip()
                cvss_score = float(cvss_input) if cvss_input else 0.0
                
                report.add_finding(title, severity, description, impact, 
                                 recommendation, cvss_score)
                print(f"‚úÖ Finding '{title}' added successfully")
            except ValueError as e:
                print(f"‚ùå Error adding finding: {e}")
                continue
            
            if input("\nAdd another finding? (y/N): ").lower() != 'y':
                break
        
        # Send report
        if report.findings:
            print("\nüì§ Sending report...")
            
            # Send summary
            summary = report.generate_summary()
            if await bot.send_message(chat_id, summary):
                print("‚úÖ Summary sent successfully")
            
            # Send individual findings
            for i in range(1, len(report.findings) + 1):
                finding_text = report.format_finding(i)
                if await bot.send_message(chat_id, finding_text):
                    print(f"‚úÖ Finding #{i} sent successfully")
                else:
                    print(f"‚ùå Failed to send finding #{i}")
            
            # Export to JSON
            json_filename = f"pentest_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            if report.export_to_json(json_filename):
                print(f"üìÑ Report exported to {json_filename}")
                
                # Send JSON file
                if await bot.send_document(chat_id, json_filename, 
                                         "Complete penetration test report (JSON format)"):
                    print("‚úÖ JSON report sent successfully")
        else:
            print("‚ö†Ô∏è  No findings added to report")


async def main():
    """Main function to handle command-line arguments and execute the bot."""
    parser = argparse.ArgumentParser(
        description="Telegram Bot for Penetration Testing Reports",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --token 123456:ABC-DEF --chat-id @mychannel
  %(prog)s --config config.json
  %(prog)s --interactive
        """
    )
    
    parser.add_argument('--token', help='Telegram bot token')
    parser.add_argument('--chat-id', help='Telegram chat ID or username')
    parser.add_argument('--config', help='Path to JSON configuration file')
    parser.add_argument('--interactive', action='store_true', 
                       help='Run in interactive mode')
    parser.add_argument('--version', action='version', version='%(prog)s 1.0.0')
    
    args = parser.parse_args()
    
    # Interactive mode
    if args.interactive:
        await interactive_mode()
        return
    
    # Configuration file mode
    if args.config:
        config = load_config(args.config)
        if not config:
            print("‚ùå Failed to load configuration file")
            sys.exit(1)
        
        token = config.get('token')
        chat_id = config.get('chat_id')
    else:
        token = args.token
        chat_id = args.chat_id
    
    # Validate required arguments
    if not token or not chat_id:
        print("‚ùå Bot token and chat ID are required")
        print("Use --interactive mode or provide --token and --chat-id arguments")
        sys.exit(1)
    
    if not validate_inputs(token, chat_id):
        sys.exit(1)
    
    # Test bot connection
    async with TelegramBot(token) as bot:
        if await bot.verify_bot_token():
            test_message = "üîí Telegram Pentest Bot is ready!\nUse --interactive mode to create reports."
            if await bot.send_message(chat_id, test_message):
                print("‚úÖ Bot is working correctly")
            else:
                print("‚ùå Failed to send test message")
        else:
            print("‚ùå Bot verification failed")
            sys.exit(1)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüëã Goodbye!")
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
        sys.exit(1)